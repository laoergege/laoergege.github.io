<!DOCTYPE html>
<html lang="zh-CN" data-theme="cupcake">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.46">
    <link rel="manifest" href="/site.webmanifest.json"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><title>容器启动运行模式以及附加分离原理 | </title><meta name="description" content="在发现很多教程文档里进行容器交互时都是直接使用 `-it` 参数为例子，并没有更多解释说明 `-i`、`-t` 的含义及区别，笔者带着疑惑试图去理解说明其中原理，本文中如有错误麻烦指出 😀。">
    <link rel="preload" href="/assets/js/runtime~app.7d4bd660.js" as="script"><link rel="preload" href="/assets/css/styles.1c65b737.css" as="style"><link rel="preload" href="/assets/js/5838.13a569e5.js" as="script"><link rel="preload" href="/assets/js/app.7e792774.js" as="script"><link rel="prefetch" href="/assets/js/v-03fc2322.47d94022.js"><link rel="prefetch" href="/assets/js/v-ba2c1988.3632b5e0.js"><link rel="prefetch" href="/assets/js/v-fd8e5af2.a9cafb88.js"><link rel="prefetch" href="/assets/js/v-5a071f34.190f1fdc.js"><link rel="prefetch" href="/assets/js/v-317472f1.a3c9dba2.js"><link rel="prefetch" href="/assets/js/v-560b844b.09f8a065.js"><link rel="prefetch" href="/assets/js/v-85bc3e4c.27575d9e.js"><link rel="prefetch" href="/assets/js/v-4835f72d.209f9a9b.js"><link rel="prefetch" href="/assets/js/v-6f2abf9c.c6a52b82.js"><link rel="prefetch" href="/assets/js/v-32c68258.46247de2.js"><link rel="prefetch" href="/assets/js/v-04983e79.ae40370a.js"><link rel="prefetch" href="/assets/js/v-7269d92e.00653b56.js"><link rel="prefetch" href="/assets/js/v-54e51afe.e3f20358.js"><link rel="prefetch" href="/assets/js/v-5fbdabee.afcc17b5.js"><link rel="prefetch" href="/assets/js/v-928f5a14.0a4a3dc4.js"><link rel="prefetch" href="/assets/js/v-88c7f226.529f6212.js"><link rel="prefetch" href="/assets/js/v-5e99732b.68dd2407.js"><link rel="prefetch" href="/assets/js/v-2fc78b4d.97b37f50.js"><link rel="prefetch" href="/assets/js/v-d99bba28.2cf82742.js"><link rel="prefetch" href="/assets/js/v-bee2f4a8.f072eb83.js"><link rel="prefetch" href="/assets/js/v-57ad8616.44af159f.js"><link rel="prefetch" href="/assets/js/v-f701b528.aa7f8f17.js"><link rel="prefetch" href="/assets/js/v-093d016d.bc725dd1.js"><link rel="prefetch" href="/assets/js/v-06ed95cc.0db5595a.js"><link rel="prefetch" href="/assets/js/v-01b20944.db789013.js"><link rel="prefetch" href="/assets/js/v-137d7552.50039c10.js"><link rel="prefetch" href="/assets/css/5045.styles.72ac531f.css"><link rel="prefetch" href="/assets/js/v-631fc68a.80740d81.js"><link rel="prefetch" href="/assets/js/v-8b5f7690.191ba9a3.js"><link rel="prefetch" href="/assets/js/v-530f22f6.f8e361fa.js"><link rel="prefetch" href="/assets/js/v-be2646cc.549f65bf.js"><link rel="prefetch" href="/assets/js/v-75e44f07.2f8601c3.js"><link rel="prefetch" href="/assets/js/v-c2504efe.28c55f92.js"><link rel="prefetch" href="/assets/js/v-5bc51cd9.b23c2caa.js"><link rel="prefetch" href="/assets/js/5956.f176ea33.js"><link rel="prefetch" href="/assets/js/v-6dc8e518.a8181c32.js"><link rel="prefetch" href="/assets/js/v-568d3b89.483d19f1.js"><link rel="prefetch" href="/assets/js/v-743faa02.3247db36.js"><link rel="prefetch" href="/assets/js/v-d52c6cc0.34d4b256.js"><link rel="prefetch" href="/assets/js/v-78263bfa.b7cb21e4.js"><link rel="prefetch" href="/assets/js/v-199de1f8.16ad6f91.js"><link rel="prefetch" href="/assets/js/v-30078430.3079f1d2.js"><link rel="prefetch" href="/assets/js/v-240dbb06.02e786fb.js"><link rel="prefetch" href="/assets/js/v-7a102f72.94a1b7e7.js"><link rel="prefetch" href="/assets/js/v-1402111c.9dc8cc11.js"><link rel="prefetch" href="/assets/js/v-f2bbc8da.fc4d9aa5.js"><link rel="prefetch" href="/assets/js/v-b0176dc2.b994ff0c.js"><link rel="prefetch" href="/assets/js/4644.1787b6ff.js"><link rel="prefetch" href="/assets/js/v-a5da5a08.cc633de8.js"><link rel="prefetch" href="/assets/js/v-acadbc84.800a32fa.js"><link rel="prefetch" href="/assets/js/v-a270a8ca.ea9c331c.js"><link rel="prefetch" href="/assets/js/v-a9440b46.63ee3544.js"><link rel="prefetch" href="/assets/js/6929.46233b49.js"><link rel="prefetch" href="/assets/js/9840.789f773b.js"><link rel="prefetch" href="/assets/js/v-9f06f78c.ff18832e.js"><link rel="prefetch" href="/assets/js/9870.c84a31ac.js"><link rel="prefetch" href="/assets/js/v-8daa1a0e.8245b191.js"><link rel="prefetch" href="/sw.js"><link rel="prefetch" href="/assets/css/3859.styles.7057c730.css">
    <link rel="stylesheet" href="/assets/css/styles.1c65b737.css">
</head>

<body>
    <div id="app"><!--[--><!--[--><div class="navbar sticky top-0 z-10"><a href="/" class=""><label class="btn btn-circle avatar"><div class="rounded-full ring ring-white shadow-2xl no-zoom"><img src="/avatar.webp"></div></label></a></div><div class="min-h-screen flex justify-center flex-col items-center"><article class="article w-full sm:w-3/4 lg:w-2/3 p-4" data-theme="cupcake"><div class="sm:max-w-full pb-12 prose sm:prose-sm md:prose-lg dark:prose-invert"><h1 id="容器启动运行模式以及附加分离原理" tabindex="-1"><a class="header-anchor" href="#容器启动运行模式以及附加分离原理" aria-hidden="true">#</a> 容器启动运行模式以及附加分离原理</h1><p>在发现很多教程文档里进行容器交互时都是直接使用 <code>-it</code> 参数为例子，并没有更多解释说明 <code>-i</code>、<code>-t</code> 的含义及区别，笔者带着疑惑试图去理解说明其中原理，本文中如有错误麻烦指出 😀。</p><blockquote><p>以下例子中使用 podman 工具，与 docker 客户端操作相同。</p></blockquote><h2 id="容器启动模式" tabindex="-1"><a class="header-anchor" href="#容器启动模式" aria-hidden="true">#</a> 容器启动模式</h2><p>在制作镜像时，Dockerfile 必须至少指定 CMD 或 ENTRYPOINT 其中的一个来启动默认程序，通常我们会有以下三种程序运行模型：</p><ul><li>默认模式：直接运行一个可执行程序，执行完输出结果即结束</li><li>交互模式：前台启动一个可持续交互运行的程序</li><li>分离模式：启动一个后台持续运行的程序</li></ul><h2 id="默认模式" tabindex="-1"><a class="header-anchor" href="#默认模式" aria-hidden="true">#</a> 默认模式</h2><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ podman run --rm ubuntu </span><span style="color:#0550AE;">pwd</span></span>
<span class="line"><span style="color:#24292F;">/</span></span>
<span class="line"></span></code></pre></div><p>执行完 pwd 命令后容器就结束退出，然后在 <code>--rm</code> 效果下自动删除容器：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ podman ps -a              </span></span>
<span class="line"><span style="color:#24292F;">CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><h2 id="分离模式" tabindex="-1"><a class="header-anchor" href="#分离模式" aria-hidden="true">#</a> 分离模式</h2><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm -d nginx</span></span>
<span class="line"><span style="color:#24292F;">...</span></span>
<span class="line"></span></code></pre></div><p>在进程完成之前我们不能返回到我们的 shell 提示符。上面的命令将标准输出 ( stdout ) 和标准错误 ( stderr ) 流与我们的终端链接。因此，我们可以在终端中看到容器的控制台输出。</p><p>分离模式把容器作为守护进程，并与会话的控制终端分离。我们使用 <code>-d|--detach</code> 选项以分离模式运行容器：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm -d nginx</span></span>
<span class="line"><span style="color:#24292F;">43765140fad728f0241c75f4f5be5b924b7a5cbee632af15ac045157bd6502a1</span></span>
<span class="line"></span></code></pre></div><h2 id="交互模式" tabindex="-1"><a class="header-anchor" href="#交互模式" aria-hidden="true">#</a> 交互模式</h2><p><code>-a|--attach</code>：即将终端附加到容器的标准流（STDIN, STDOUT和STDERR），这意味着我们可以通过终端输入输出与进程交互。如果没有指定 <code>-a</code> 选项，默认会 attach stdout 和 stderr。上面的命令效果相当于下面：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ podman run --rm -a stdout -a stderr ubuntu </span><span style="color:#0550AE;">pwd</span></span>
<span class="line"><span style="color:#24292F;">/</span></span>
<span class="line"></span></code></pre></div><p>但是当我们执行以下命令开启与 bash 交互，却发现容器给停止了。</p><blockquote><p>ubunut 镜像默认启动程序 Bash</p></blockquote><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ podman run --rm -a stdin -a stdout ubuntu</span></span>
<span class="line"></span></code></pre></div><p>尽管我们 attach 容器的 stdin，<strong>但容器的输入流实际上是关闭的</strong>：</p><p>先通过 sleep 启动阻塞程序，</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ podman run --rm -a stdin -a stdout ubuntu sleep 30000</span></span>
<span class="line"></span></code></pre></div><p>再通过另一个终端查看详情：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ lsns</span></span>
<span class="line"><span style="color:#24292F;">        NS TYPE   NPROCS   PID USER COMMAND</span></span>
<span class="line"><span style="color:#24292F;">4026531834 </span><span style="color:#CF222E;">time</span><span style="color:#24292F;">       13  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531835 cgroup     12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531836 pid       129  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531837 user        7  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531838 uts        12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531839 ipc        12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531840 net        12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531841 mnt         7  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026532285 user      123  1649 core catatonit -P</span></span>
<span class="line"><span style="color:#24292F;">4026532351 mnt         4  1649 core catatonit -P</span></span>
<span class="line"><span style="color:#24292F;">4026532422 net         1 25717 core sleep 30000</span></span>
<span class="line"><span style="color:#24292F;">4026532545 mnt         1 25717 core sleep 30000</span></span>
<span class="line"><span style="color:#24292F;">4026532546 mnt         1 25679 core /usr/bin/slirp4netns --disable-host-loopback --mtu=65520 --enable-sandbox --enable-seccomp --enable-ipv6 -c -r 3 --netns-t</span></span>
<span class="line"><span style="color:#24292F;">4026532550 uts         1 25717 core sleep 30000</span></span>
<span class="line"><span style="color:#24292F;">4026532551 ipc         1 25717 core sleep 30000</span></span>
<span class="line"><span style="color:#24292F;">4026532552 pid         1 25717 core sleep 30000</span></span>
<span class="line"><span style="color:#24292F;">4026532553 cgroup      1 25717 core sleep 30000</span></span>
<span class="line"></span></code></pre></div><p>进程 25717 即我们刚刚启动的容器。</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ lsof -p 25717</span></span>
<span class="line"><span style="color:#24292F;">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core  cwd    DIR   0,49       28  41943573 /</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core  rtd    DIR   0,49       28  41943573 /</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core  txt    REG   0,49    35000 134218012 /bin/sleep</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core  mem    REG  252,4          134218012 /bin/sleep (path dev=0,46, inode=2885535)</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core  mem    REG  252,4          202375315 /lib/x86_64-linux-gnu/libc-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core  mem    REG  252,4          202375297 /lib/x86_64-linux-gnu/ld-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core    0u   CHR    1,3      0t0         4 /dev/null</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core    1w  FIFO   0,13      0t0   2328957 pipe</span></span>
<span class="line"><span style="color:#24292F;">sleep   25717 core    2w  FIFO   0,13      0t0   2328958 pipe</span></span>
<span class="line"></span></code></pre></div><p>其中 <code>sleep 25717 core 0u CHR 1,3 0t0 4 /dev/null</code> 的 <code>0u</code> 即是容器的输入流，发现是字符设备 <code>/dev/null</code>。</p><blockquote><p>Linux 中的 <code>/dev/null</code> 是一个空设备文件。这将丢弃任何写入它的内容，并在读取时返回 EOF。</p></blockquote><h3 id="interactive-选项" tabindex="-1"><a class="header-anchor" href="#interactive-选项" aria-hidden="true">#</a> interactive 选项</h3><p><code>-i|--interactive</code>：让容器的标准输入保持打开状态，即使容器的标准输入，输出和错误流没有被附加。</p><p>附带 <code>-i</code> 时 <code>-a stdin</code> 相当默认带上。重复上面实验操作：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm -i ubuntus</span></span>
<span class="line"></span></code></pre></div><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ lsns</span></span>
<span class="line"><span style="color:#24292F;">        NS TYPE   NPROCS   PID USER COMMAND</span></span>
<span class="line"><span style="color:#24292F;">4026531834 </span><span style="color:#CF222E;">time</span><span style="color:#24292F;">       13  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531835 cgroup     12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531836 pid       129  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531837 user        7  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531838 uts        12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531839 ipc        12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531840 net        12  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026531841 mnt         7  1460 core /usr/lib/systemd/systemd --user</span></span>
<span class="line"><span style="color:#24292F;">4026532285 user      123  1649 core catatonit -P</span></span>
<span class="line"><span style="color:#24292F;">4026532351 mnt         4  1649 core catatonit -P</span></span>
<span class="line"><span style="color:#24292F;">4026532422 net         1 25827 core bash</span></span>
<span class="line"><span style="color:#24292F;">4026532545 mnt         1 25827 core bash</span></span>
<span class="line"><span style="color:#24292F;">4026532546 mnt         1 25791 core /usr/bin/slirp4netns --disable-host-loopback --mtu=65520 --enable-sandbox --enable-seccomp --enable-ipv6 -c -r 3 --netns-t</span></span>
<span class="line"><span style="color:#24292F;">4026532550 uts         1 25827 core bash</span></span>
<span class="line"><span style="color:#24292F;">4026532551 ipc         1 25827 core bash</span></span>
<span class="line"><span style="color:#24292F;">4026532552 pid         1 25827 core bash</span></span>
<span class="line"><span style="color:#24292F;">4026532553 cgroup      1 25827 core bash</span></span>
<span class="line"></span></code></pre></div><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ lsof -p 25827</span></span>
<span class="line"><span style="color:#24292F;">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  cwd    DIR   0,49       28  57671966 /</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  rtd    DIR   0,49       28  57671966 /</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  txt    REG   0,49  1113504 134217858 /bin/bash</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          134217858 /bin/bash (path dev=0,46, inode=2117823)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375451 /lib/x86_64-linux-gnu/libnss_files-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375445 /lib/x86_64-linux-gnu/libnsl-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375455 /lib/x86_64-linux-gnu/libnss_nis-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375447 /lib/x86_64-linux-gnu/libnss_compat-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375315 /lib/x86_64-linux-gnu/libc-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375355 /lib/x86_64-linux-gnu/libdl-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375489 /lib/x86_64-linux-gnu/libtinfo.so.5.9 (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core  mem    REG  252,4          202375297 /lib/x86_64-linux-gnu/ld-2.27.so (stat: No such file or directory)</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core    0r  FIFO   0,13      0t0   2329821 pipe</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core    1w  FIFO   0,13      0t0   2329822 pipe</span></span>
<span class="line"><span style="color:#24292F;">bash    25827 core    2w  FIFO   0,13      0t0   2329823 pipe</span></span>
<span class="line"></span></code></pre></div><p>这次发现输入流是一个命名管道，终端与容器之间的交互是通过管道文件！实际上除了通过管道文件进行交互，还能通过 TTY 设备文件。</p><h3 id="tty-选项" tabindex="-1"><a class="header-anchor" href="#tty-选项" aria-hidden="true">#</a> tty 选项</h3><blockquote><p>了解更多 <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TTY.html" class="">TTY</a></p></blockquote><p>TTY (电传打字机 teletype 的缩写) 过去是计算机附加的终端设备，现在 Linux 的中 TTY 是一个软件仿真终端的概念，当我们打开一个终端软件如 zsh，在“一切皆文件”的 Linux 中有着对应的设备文件，输入 <code>tty</code> 可查到对应的设备文件：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ tty</span></span>
<span class="line"><span style="color:#24292F;">/dev/ttys003</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>为此，我们只需要把容器的标准流绑定到 TTY 上，对着 TTY 设备文件读写即可与用户终端进行交互。当用户在控制台中启动普通程序时，通常其 stdin、stdout 和 stderr 流将连接到会话的控制终端：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ tty</span></span>
<span class="line"><span style="color:#24292F;">/dev/ttys003</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">$ cat            </span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>然后在打开另一个终端，查找 cat 进程相关信息</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ tty</span></span>
<span class="line"><span style="color:#24292F;">/dev/ttys004</span></span>
<span class="line"><span style="color:#24292F;">$ lsof -p 18825     </span></span>
<span class="line"><span style="color:#24292F;">...</span></span>
<span class="line"><span style="color:#24292F;">cat     18825 lianyuansheng    0u   CHR   16,3    0t373                1525 /dev/ttys003</span></span>
<span class="line"><span style="color:#24292F;">cat     18825 lianyuansheng    1u   CHR   16,3    0t373                1525 /dev/ttys003</span></span>
<span class="line"><span style="color:#24292F;">cat     18825 lianyuansheng    2u   CHR   16,3    0t373                1525 /dev/ttys003</span></span>
<span class="line"><span style="color:#24292F;">...</span></span>
<span class="line"></span></code></pre></div><p>可以看出 cat 子进程的标准流自动绑定到 ttys003 上。但进程的控制终端不一定总是与它的流所连接的终端相同。您可以使用以下ps命令查看这些内容：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">$ sudo ps -ax -o pid,tty</span></span>
<span class="line"><span style="color:#24292F;">  PID TTY</span></span>
<span class="line"><span style="color:#24292F;">    1 </span><span style="color:#CF222E;">??</span></span>
<span class="line"><span style="color:#24292F;">   50 ttys003</span></span>
<span class="line"><span style="color:#24292F;">   51 </span><span style="color:#CF222E;">??</span></span>
<span class="line"></span></code></pre></div><ul><li>TTY 列表示进程的控制终端</li><li>?? 意味着守护进程</li></ul><p>回到容器的启动选项：</p><p><code>-t｜--tty</code>：为容器分配一个伪 TTY 终端并绑定到容器的标准输上。</p><p>上面所说的 TTY 是内核提供的作为系统操作交互的一部分，而伪终端 PTY（pseudo TTY）则是运行在用户态，可自定义于进程间的交互。通过打开特殊的设备文件 /dev/ptmx 创建，由一对双向的字符设备构成，称为 PTY master 和 PTY slave， PTY master 和 PTY slave 之间进行双向读写。</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm -t -a stdout -a stdin ubuntu</span></span>
<span class="line"><span style="color:#24292F;">root@f1dc70c90896:/</span><span style="color:#6E7781;"># pwd</span></span>
<span class="line"><span style="color:#24292F;">/</span></span>
<span class="line"><span style="color:#24292F;">root@f1dc70c90896:/</span><span style="color:#6E7781;"># </span></span>
<span class="line"></span></code></pre></div><p>启动另一个终端查看到进程绑定了 PTY slave：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ lsof -p 29269</span></span>
<span class="line"><span style="color:#24292F;">...</span></span>
<span class="line"><span style="color:#24292F;">bash    29269 core    0u   CHR  136,0      0t0         3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">bash    29269 core    1u   CHR  136,0      0t0         3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">bash    29269 core    2u   CHR  136,0      0t0         3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">...</span></span>
<span class="line"></span></code></pre></div><p>那么 PTY master 呢？PTY master 是绑定在哪里？由谁操作？查看终端与 Podman 进程关联到同一 PTY 设备文件：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ ps a</span></span>
<span class="line"><span style="color:#24292F;">...</span></span>
<span class="line"><span style="color:#24292F;">29188 pts/0    Ss     0:00 -bash</span></span>
<span class="line"><span style="color:#24292F;">29223 pts/0    Sl+    0:09 podman run --rm -t -a stdin -a stdout ubuntu</span></span>
<span class="line"><span style="color:#24292F;">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ lsof /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span></span>
<span class="line"><span style="color:#24292F;">bash    29188 core    0u   CHR  136,0      0t0    3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">bash    29188 core    1u   CHR  136,0      0t0    3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">bash    29188 core    2u   CHR  136,0      0t0    3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">bash    29188 core  255u   CHR  136,0      0t0    3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">podman  29223 core    0u   CHR  136,0      0t0    3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">podman  29223 core    1u   CHR  136,0      0t0    3 /dev/pts/0</span></span>
<span class="line"><span style="color:#24292F;">podman  29223 core    2u   CHR  136,0      0t0    3 /dev/pts/0</span></span>
<span class="line"></span></code></pre></div><p>整体架构如下：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">+----------+                +----------+                                      +---------------+</span></span>
<span class="line"><span style="color:#CF222E;">|</span><span style="color:#24292F;"> Terminal </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> ---[attach]--- </span><span style="color:#CF222E;">|</span><span style="color:#24292F;">  Podman  </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">&lt;</span><span style="color:#24292F;">-- [pty] -- read/write -- [pts] --</span><span style="color:#CF222E;">&gt;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;">   Container   </span><span style="color:#CF222E;">|</span></span>
<span class="line"><span style="color:#24292F;">+----------+                +----------+                                      +---------------+</span></span>
<span class="line"></span></code></pre></div><p><strong>Terminal Fork 出的 Podman 进程并且其持有 PTY master 设备。这样通过中间的 Podman 进程，终端即可间接与容器交互</strong>。</p><p>后半部分可以换做管道 FIFO，即 <code>-i</code> 参数下的模式：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">+----------+                +----------+              +---------------+</span></span>
<span class="line"><span style="color:#CF222E;">|</span><span style="color:#24292F;"> Terminal </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> ---[attach]--- </span><span style="color:#CF222E;">|</span><span style="color:#24292F;">  Podman  </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">&lt;</span><span style="color:#24292F;">-- FIFO --</span><span style="color:#CF222E;">&gt;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;">   Container   </span><span style="color:#CF222E;">|</span></span>
<span class="line"><span style="color:#24292F;">+----------+                +----------+              +---------------+</span></span>
<span class="line"></span></code></pre></div><h3 id="it" tabindex="-1"><a class="header-anchor" href="#it" aria-hidden="true">#</a> -it</h3><p>从前面我们知道容器交互的原理，并且有两个交互启动参数：</p><ul><li><code>-i</code>：打开容器输入流，通过管道文件交互</li><li><code>-t</code>：为容器分配伪终端，通过伪终端设备文件交互</li></ul><p>但通常我们会更推荐使用 <code>-it</code> 组合参数：</p><ul><li><code>-i</code>：将终端附加到容器</li><li>通过伪终端与进程交互，因为终端（包括伪终端）具有某些属性可以控制显示格式</li><li>并且还会拦截处理特殊键序，发送进程信号，比如 <ul><li>当用户按 CTRL+c 时，它向连接到 PTY slave 的进程发送 kill -2（SIGINT） 信号</li><li>当用户按 CTRL+z 时，它向连接到 PTY slave 的进程发送 kill -STOP 信号</li></ul></li></ul><h2 id="从附加模式中分离" tabindex="-1"><a class="header-anchor" href="#从附加模式中分离" aria-hidden="true">#</a> 从附加模式中分离</h2><p><code>CTRL-c</code> 通常是终端结束会话回到原 shell 提示符的常用方法。而在附加模式（默认模式和交互模式）下的容器，输入 <code>CTRL-c</code> 可能会导致容器停止。以附加模式启动的 nginx：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm nginx</span></span>
<span class="line"></span></code></pre></div><p>在键盘输入 <code>CTRL-c</code> 后容器停止。有时我们不希望 <code>CTRL+c</code> 断开时杀死容器，那怎么办？实际原理上 <code>CTRL-c</code> 会被终端拦截发送成 SIGINT 信号，然后被 Podman 代理转发到容器：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">+----------+                 +----------+               +---------------+</span></span>
<span class="line"><span style="color:#CF222E;">|</span><span style="color:#24292F;"> Terminal </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> ---[Signal]---</span><span style="color:#CF222E;">&gt;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;">  Podman  </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> --[Signal]--</span><span style="color:#CF222E;">&gt;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;">   Container   </span><span style="color:#CF222E;">|</span></span>
<span class="line"><span style="color:#24292F;">+----------+                 +----------+               +---------------+</span></span>
<span class="line"></span></code></pre></div><p>让我们覆盖传递 <code>-–sig-proxy=false</code> 的行为：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm --sig-proxy=false  nginx</span></span>
<span class="line"><span style="color:#24292F;">...输出省略</span></span>
<span class="line"></span></code></pre></div><p>输入 <code>CTRL-c</code> 后，容器还在后台运行。</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">^C[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman ps</span></span>
<span class="line"><span style="color:#24292F;">CONTAINER ID  IMAGE                   COMMAND               CREATED        STATUS            PORTS       NAMES</span></span>
<span class="line"><span style="color:#24292F;">59841a040b52  localhost/nginx:latest  nginx -g daemon o...  5 seconds ago  Up 5 seconds ago              gallant_shirley</span></span>
<span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$  </span></span>
<span class="line"></span></code></pre></div><p>其实在这过程分了终端与容器，最终被销毁的是中间的 Podman 进程。我们在终端输入以下命令，不断循环捕获 SIGINT 信号，然后按 <code>CTRL-c</code> ：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm --sig-proxy=false ubuntu /bin/bash -c </span><span style="color:#0A3069;">&#39;trap &quot;echo got it&quot; 2;while :;do sleep 0.1;done&#39;</span></span>
<span class="line"><span style="color:#24292F;">^C[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ </span></span>
<span class="line"></span></code></pre></div><p>在另一个终端查询进程信息：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ ps a</span></span>
<span class="line"><span style="color:#24292F;">    PID TTY      STAT   TIME COMMAND</span></span>
<span class="line"><span style="color:#24292F;">   5452 pts/0    Ss     0:00 -bash</span></span>
<span class="line"><span style="color:#24292F;"> 100715 pts/0    Sl+    0:00 podman run --rm --sig-proxy=false ubuntu /bin/bash -c </span><span style="color:#0550AE;">trap</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;echo got it&quot;</span><span style="color:#24292F;"> 2</span><span style="color:#CF222E;">;while</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">:</span><span style="color:#CF222E;">;do</span><span style="color:#24292F;"> sleep 0.1</span><span style="color:#CF222E;">;done</span></span>
<span class="line"><span style="color:#24292F;"> 100933 pts/1    R+     0:00 ps a</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">// 输入 </span><span style="color:#0A3069;">`CTRL-c`</span><span style="color:#24292F;"> 后</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ ps a</span></span>
<span class="line"><span style="color:#24292F;">    PID TTY      STAT   TIME COMMAND</span></span>
<span class="line"><span style="color:#24292F;">   5452 pts/0    Ss+    0:00 -bash</span></span>
<span class="line"><span style="color:#24292F;"> 101053 pts/1    R+     0:00 ps a</span></span>
<span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman ps</span></span>
<span class="line"><span style="color:#24292F;">CONTAINER ID  IMAGE                    COMMAND               CREATED         STATUS             PORTS       NAMES</span></span>
<span class="line"><span style="color:#24292F;">cb060aeb4618  localhost/ubuntu:latest  /bin/bash -c trap...  43 seconds ago  Up 43 seconds ago              romantic_villani</span></span>
<span class="line"></span></code></pre></div><p>从实验上看，输入 <code>CTRL-c</code> 后，并没有捕获到信号输出 <code>echo got it</code>；podman 进程销毁了；而容器依旧还在运行。</p><p>再来看个交互模式下的例子：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm --sig-proxy=false -it nginx</span></span>
<span class="line"><span style="color:#24292F;">...输出省略</span></span>
<span class="line"></span></code></pre></div><p>输入 <code>CTRL-c</code> 后发现容器竟然终止了，<code>-–sig-proxy=false</code> 不起效，原因是作为 TTY 交互模式下，<code>CTRL-c</code> 殊键序作为伪终端输入会被拦截处理特，发送信号给了容器里的 1 号进程。</p><p>所以<strong>在附加模式下与容器分离时要特别注意对容器造成影响</strong>。可通过 <code>--detach-keys</code> 可以自定义分离键序：</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm --sig-proxy=false -it --detach-keys=</span><span style="color:#0A3069;">&quot;ctrl-x&quot;</span><span style="color:#24292F;">  nginx</span></span>
<span class="line"><span style="color:#24292F;">...输出省略</span></span>
<span class="line"></span></code></pre></div><p>键入 <code>CTRL-x</code> 后，容器还在后台运行。</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman ps</span></span>
<span class="line"><span style="color:#24292F;">CONTAINER ID  IMAGE                   COMMAND               CREATED        STATUS            PORTS       NAMES</span></span>
<span class="line"><span style="color:#24292F;">fdaa412851a2  localhost/nginx:latest  nginx -g daemon o...  6 seconds ago  Up 6 seconds ago              sweet_hofstadter</span></span>
<span class="line"></span></code></pre></div><h2 id="kill-1-号进程" tabindex="-1"><a class="header-anchor" href="#kill-1-号进程" aria-hidden="true">#</a> kill 1 号进程</h2><p>有了前面经验后，我们尝试下面例子，却发现再怎么输入 <code>CTRL-c</code> 都没法终止容器回到原终端。难道容器没有收到 SIGINT 信号？其实不然。</p><div class="language-bash ext-sh"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[core@localhost </span><span style="color:#CF222E;">~</span><span style="color:#24292F;">]$ podman run --rm -it ubuntu</span></span>
<span class="line"><span style="color:#24292F;">root@6df454625261:/</span><span style="color:#6E7781;"># ^C</span></span>
<span class="line"><span style="color:#24292F;">root@6df454625261:/</span><span style="color:#6E7781;"># ^C</span></span>
<span class="line"><span style="color:#24292F;">root@6df454625261:/</span><span style="color:#6E7781;"># </span></span>
<span class="line"></span></code></pre></div><blockquote><p>答案参考《容器实战高手课》- 02 | 理解进程（1）：为什么我在容器中不能kill 1号进程？</p></blockquote><p>TL;DR：</p><ol><li>每个容器内部都会启动一个用户态的 init 进程，称为 1 号进程。1 号进程最基本的功能都是创建出 Linux 系统中其他所有的进程，并且管理这些进程。虽然最佳方式是一个容器只启动一个进程，但我们难免会启动一些监控进程等，而且很多时候跑在容器的应用服务是多进程架构。</li><li>Linux 内核针对每个 Nnamespace 里的 init 进程，把只有 default handler 的信号都给忽略了</li><li>用户可以自己注册了 handler 编码退出，这样初始进程是可以响应 SIGINT 或 SIGTERM 等信号</li><li>但请注意在 Linux 中 SIGKILL 和 SIGSTOP 这两个特权信号不允许自定义捕获</li></ol><h2 id="attach-vs-exec-有什么区别" tabindex="-1"><a class="header-anchor" href="#attach-vs-exec-有什么区别" aria-hidden="true">#</a> attach vs exec - 有什么区别？</h2><p>与正在运行的容器进行交互有两条命令：</p><ul><li><code>podman attach &lt;cid&gt;</code>：跟容器的 1 号进程交互</li><li><code>podman exec &lt;cid&gt; [option] &lt;commond&gt;</code>：在容器中启动新的进程执行命令</li></ul><p>理解了前面内容，这两条命令原理也就差不多了。<strong>区分它们关键在于是否与容器 1 号进程交互</strong>，同时要注意对信号对容器的影响。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>最后总结，主要理解：</p><ul><li>容器的启动运行模式：附加模式、分离模式 <ul><li>附加模式 <ul><li>默认模式</li><li>交互模式</li></ul></li></ul></li></ul><p>还有交互模式下 <code>-i</code>（使用管道）、<code>-t</code>（使用 TTY） 区别以及大致架构 <code>Terminal = Podman &lt;=&gt; Container</code>。最后容器对信号量处理问题（忽略所有信号，除非自定义捕获），需要特别注意对容器影响。</p></div><!----></article></div><footer class="footer footer-center p-4 bg-base-300 text-base-content opacity-60"><div><p>©2017-2021 laoergege.cn. All right reserved. </p><p><a href="https://beian.miit.gov.cn" target="_blank" class="link link-hover">粤ICP备2022020679号</a></p></div></footer><!--]--><!----><!--]--></div>
    <script src="/assets/js/runtime~app.7d4bd660.js" defer></script><script src="/assets/js/5838.13a569e5.js" defer></script><script src="/assets/js/app.7e792774.js" defer></script>
</body>

</html>