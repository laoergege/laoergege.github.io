<!DOCTYPE html>
<html lang="zh-CN" data-theme="cupcake">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.46">
    <link rel="manifest" href="/site.webmanifest.json"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><title>Vue 的响应式渲染机制 | </title><meta name="description" content="Just For Fun">
    <link rel="preload" href="/assets/js/runtime~app.7d4bd660.js" as="script"><link rel="preload" href="/assets/css/styles.1c65b737.css" as="style"><link rel="preload" href="/assets/js/5838.13a569e5.js" as="script"><link rel="preload" href="/assets/js/app.7e792774.js" as="script"><link rel="prefetch" href="/assets/js/v-03fc2322.47d94022.js"><link rel="prefetch" href="/assets/js/v-ba2c1988.3632b5e0.js"><link rel="prefetch" href="/assets/js/v-fd8e5af2.a9cafb88.js"><link rel="prefetch" href="/assets/js/v-5a071f34.190f1fdc.js"><link rel="prefetch" href="/assets/js/v-317472f1.a3c9dba2.js"><link rel="prefetch" href="/assets/js/v-560b844b.09f8a065.js"><link rel="prefetch" href="/assets/js/v-85bc3e4c.27575d9e.js"><link rel="prefetch" href="/assets/js/v-4835f72d.209f9a9b.js"><link rel="prefetch" href="/assets/js/v-6f2abf9c.c6a52b82.js"><link rel="prefetch" href="/assets/js/v-32c68258.46247de2.js"><link rel="prefetch" href="/assets/js/v-04983e79.ae40370a.js"><link rel="prefetch" href="/assets/js/v-7269d92e.00653b56.js"><link rel="prefetch" href="/assets/js/v-54e51afe.e3f20358.js"><link rel="prefetch" href="/assets/js/v-5fbdabee.afcc17b5.js"><link rel="prefetch" href="/assets/js/v-928f5a14.0a4a3dc4.js"><link rel="prefetch" href="/assets/js/v-88c7f226.529f6212.js"><link rel="prefetch" href="/assets/js/v-5e99732b.68dd2407.js"><link rel="prefetch" href="/assets/js/v-2fc78b4d.97b37f50.js"><link rel="prefetch" href="/assets/js/v-d99bba28.2cf82742.js"><link rel="prefetch" href="/assets/js/v-bee2f4a8.f072eb83.js"><link rel="prefetch" href="/assets/js/v-57ad8616.44af159f.js"><link rel="prefetch" href="/assets/js/v-f701b528.aa7f8f17.js"><link rel="prefetch" href="/assets/js/v-093d016d.bc725dd1.js"><link rel="prefetch" href="/assets/js/v-06ed95cc.0db5595a.js"><link rel="prefetch" href="/assets/js/v-01b20944.db789013.js"><link rel="prefetch" href="/assets/js/v-137d7552.50039c10.js"><link rel="prefetch" href="/assets/css/5045.styles.72ac531f.css"><link rel="prefetch" href="/assets/js/v-631fc68a.80740d81.js"><link rel="prefetch" href="/assets/js/v-8b5f7690.191ba9a3.js"><link rel="prefetch" href="/assets/js/v-530f22f6.f8e361fa.js"><link rel="prefetch" href="/assets/js/v-be2646cc.549f65bf.js"><link rel="prefetch" href="/assets/js/v-75e44f07.2f8601c3.js"><link rel="prefetch" href="/assets/js/v-c2504efe.28c55f92.js"><link rel="prefetch" href="/assets/js/v-5bc51cd9.b23c2caa.js"><link rel="prefetch" href="/assets/js/5956.f176ea33.js"><link rel="prefetch" href="/assets/js/v-6dc8e518.a8181c32.js"><link rel="prefetch" href="/assets/js/v-568d3b89.483d19f1.js"><link rel="prefetch" href="/assets/js/v-743faa02.3247db36.js"><link rel="prefetch" href="/assets/js/v-d52c6cc0.34d4b256.js"><link rel="prefetch" href="/assets/js/v-78263bfa.b7cb21e4.js"><link rel="prefetch" href="/assets/js/v-199de1f8.16ad6f91.js"><link rel="prefetch" href="/assets/js/v-30078430.3079f1d2.js"><link rel="prefetch" href="/assets/js/v-240dbb06.02e786fb.js"><link rel="prefetch" href="/assets/js/v-7a102f72.94a1b7e7.js"><link rel="prefetch" href="/assets/js/v-1402111c.9dc8cc11.js"><link rel="prefetch" href="/assets/js/v-f2bbc8da.fc4d9aa5.js"><link rel="prefetch" href="/assets/js/v-b0176dc2.b994ff0c.js"><link rel="prefetch" href="/assets/js/4644.1787b6ff.js"><link rel="prefetch" href="/assets/js/v-a5da5a08.cc633de8.js"><link rel="prefetch" href="/assets/js/v-acadbc84.800a32fa.js"><link rel="prefetch" href="/assets/js/v-a270a8ca.ea9c331c.js"><link rel="prefetch" href="/assets/js/v-a9440b46.63ee3544.js"><link rel="prefetch" href="/assets/js/6929.46233b49.js"><link rel="prefetch" href="/assets/js/9840.789f773b.js"><link rel="prefetch" href="/assets/js/v-9f06f78c.ff18832e.js"><link rel="prefetch" href="/assets/js/9870.c84a31ac.js"><link rel="prefetch" href="/assets/js/v-8daa1a0e.8245b191.js"><link rel="prefetch" href="/sw.js"><link rel="prefetch" href="/assets/css/3859.styles.7057c730.css">
    <link rel="stylesheet" href="/assets/css/styles.1c65b737.css">
</head>

<body>
    <div id="app"><!--[--><!--[--><div class="navbar sticky top-0 z-10"><a href="/" class=""><label class="btn btn-circle avatar"><div class="rounded-full ring ring-white shadow-2xl no-zoom"><img src="/avatar.webp"></div></label></a></div><div class="min-h-screen flex justify-center flex-col items-center"><article class="article w-full sm:w-3/4 lg:w-2/3 p-4" data-theme="cupcake"><div class="sm:max-w-full pb-12 prose sm:prose-sm md:prose-lg dark:prose-invert"><h1 id="vue-的响应式渲染机制" tabindex="-1"><a class="header-anchor" href="#vue-的响应式渲染机制" aria-hidden="true">#</a> Vue 的响应式渲染机制</h1><blockquote><p>以下代码示例版本 vue3.2</p></blockquote><p>Vue 的响应式渲染机制，也就是 MDV（Model-Driven-View）数据驱动视图的实现原理。在 MDV 的理念下，我们只需要关注业务数据变化，至于状态变化如何自动化同步映射成 UI 就交给视图层框架解决。</p><p>在 vue 的响应式系统里，数据即响应式数据，而视图渲染则是一种副作用。</p><p><img src="/assets/img/e42d0897f1ae88b0b163646ca8b25880307282361ccb232159ade5ed8b796d52.3c22ac58.png" alt="图 11"></p><p>vue 响应式更新渲染机制:</p><p><img src="/assets/img/2aa3f18582022b697f8312ccbbb6a029a91e761ccdaa4f8e3cdabf3bc8896862.0e581755.png" alt="图 2"></p><p>vue3 的响应式渲染机制跟 vue2 其实区别不大，其中：</p><ol><li>组件渲染变成成副作用</li><li>渲染副作用执行过程触发数据依赖收集</li><li>数据变化触发更新任务进入异步队列</li><li>Scheduler 进行异步调度</li></ol><h2 id="渲染副作用-建立视图与数据的响应关联" tabindex="-1"><a class="header-anchor" href="#渲染副作用-建立视图与数据的响应关联" aria-hidden="true">#</a> 渲染副作用：建立视图与数据的响应关联</h2><p>回顾 vue 组件渲染流程：</p><ol><li>创建组件类型 vnode</li><li>渲染 vnode <ol><li>创建组件实例</li><li>初始化组件</li><li>创建组件渲染副作用并执行</li></ol></li></ol><blockquote><p>更多参考 <a href="/Vue/vue%20%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.html" class="">vue 组件渲染流程</a>。</p></blockquote><p>通过 setupRenderEffect 创建渲染副作用并执行。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// packages/runtime-core/src/renderer.ts</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">setupRenderEffect</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">SetupRenderEffectFn</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> (</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">instance</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">initialVNode</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">container</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">anchor</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">parentSuspense</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">isSVG</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#953800;">optimized</span></span>
<span class="line"><span style="color:#24292F;">  ) </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 组件更新函数</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">componentUpdateFn</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> () </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> { </span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// 执行组件 render 方法</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// create reactive effect for rendering</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 创建响应式渲染副作用</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">effect</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">new</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">ReactiveEffect</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">      componentUpdateFn,</span></span>
<span class="line"><span style="color:#24292F;">      () </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">queueJob</span><span style="color:#24292F;">(instance.update),</span></span>
<span class="line"><span style="color:#24292F;">      instance.scope </span><span style="color:#6E7781;">// track it in component&#39;s effect scope</span></span>
<span class="line"><span style="color:#24292F;">    )</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">update</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> (instance.update </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> effect.run.</span><span style="color:#8250DF;">bind</span><span style="color:#24292F;">(effect) </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> </span><span style="color:#953800;">SchedulerJob</span><span style="color:#24292F;">)</span></span>
<span class="line"><span style="color:#24292F;">    update.id </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> instance.uid</span></span>
<span class="line"><span style="color:#24292F;">   </span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">    </span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 执行渲染、触发依赖收集</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">update</span><span style="color:#24292F;">()</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"></span></code></pre></div><p>其中最主要的是执行组件的<strong>渲染函数</strong>，<strong>渲染函数是视图访问数据，建立响应式关联的关键所在</strong>。</p><p>可以通过线上<a href="https://vue-next-template-explorer.netlify.app/" target="_blank" rel="noopener noreferrer">模板编译器<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，查看编译后的渲染函数。</p><div class="language-html ext-html"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">&lt;</span><span style="color:#116329;">div</span><span style="color:#24292F;">&gt;{{name}}&lt;/</span><span style="color:#116329;">div</span><span style="color:#24292F;">&gt;</span></span>
<span class="line"></span></code></pre></div><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">import</span><span style="color:#24292F;"> { toDisplayString </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> _toDisplayString, openBlock </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> _openBlock, createElementBlock </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> _createElementBlock } </span><span style="color:#CF222E;">from</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;vue&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">render</span><span style="color:#24292F;">(</span><span style="color:#953800;">_ctx</span><span style="color:#24292F;">, </span><span style="color:#953800;">_cache</span><span style="color:#24292F;">, </span><span style="color:#953800;">$props</span><span style="color:#24292F;">, </span><span style="color:#953800;">$setup</span><span style="color:#24292F;">, </span><span style="color:#953800;">$data</span><span style="color:#24292F;">, </span><span style="color:#953800;">$options</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> (</span><span style="color:#8250DF;">_openBlock</span><span style="color:#24292F;">(), </span><span style="color:#8250DF;">_createElementBlock</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&quot;div&quot;</span><span style="color:#24292F;">, </span><span style="color:#0550AE;">null</span><span style="color:#24292F;">, </span><span style="color:#8250DF;">_toDisplayString</span><span style="color:#24292F;">(_ctx.name), </span><span style="color:#0550AE;">1</span><span style="color:#24292F;"> </span><span style="color:#6E7781;">/* TEXT */</span><span style="color:#24292F;">))</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>访问 name 时得通过 <code>_ctx.name</code>，<strong>ctx 是数据访问的上下文环境代理</strong>。</p><h2 id="渲染上下文-视图的数据访问代理" tabindex="-1"><a class="header-anchor" href="#渲染上下文-视图的数据访问代理" aria-hidden="true">#</a> 渲染上下文：视图的数据访问代理</h2><p>统一代理访问，主要是因为视图访问的数据源有多处：</p><ol><li>setupState</li><li>data</li><li>props</li><li>用户自定义添加在实例上的属性 <code>this.xxx = xxx</code></li><li>组件实例 vue 公开方法：如 <code>$options</code>、<code>$refs</code> 等</li><li>全局属性： <code>app.config.globalProperties</code> 配置</li></ol><blockquote><p>源码位置： packages/runtime-core/src/componentPublicInstance.ts @PublicInstanceProxyHandlers</p></blockquote><p>💡 数据访问顺序的影响，下面示例将输出 setup 的 msg。</p><div class="language-vue ext-vue"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">&lt;</span><span style="color:#116329;">template</span><span style="color:#24292F;">&gt;</span></span>
<span class="line"><span style="color:#24292F;">  &lt;</span><span style="color:#0550AE;">p</span><span style="color:#24292F;">&gt;{{</span><span style="color:#0550AE;">msg</span><span style="color:#24292F;">}}&lt;/</span><span style="color:#0550AE;">p</span><span style="color:#24292F;">&gt;</span></span>
<span class="line"><span style="color:#24292F;">&lt;/</span><span style="color:#116329;">template</span><span style="color:#24292F;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">&lt;</span><span style="color:#116329;">script</span><span style="color:#24292F;">&gt;</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">import</span><span style="color:#24292F;"> { ref } </span><span style="color:#CF222E;">from</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&#39;vue&#39;</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">export</span><span style="color:#953800;"> </span><span style="color:#CF222E;">default</span><span style="color:#953800;"> {</span></span>
<span class="line"><span style="color:#953800;">    </span><span style="color:#8250DF;">data</span><span style="color:#953800;">() </span><span style="color:#24292F;">{</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">        msg: </span><span style="color:#0A3069;">&#39;msg from data&#39;</span></span>
<span class="line"><span style="color:#24292F;">      }</span></span>
<span class="line"><span style="color:#24292F;">    }</span><span style="color:#953800;">,</span></span>
<span class="line"><span style="color:#953800;">    </span><span style="color:#8250DF;">setup</span><span style="color:#953800;">() </span><span style="color:#24292F;">{</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">msg</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">ref</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&#39;msg from setup&#39;</span><span style="color:#24292F;">)</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">        msg</span></span>
<span class="line"><span style="color:#24292F;">      }</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#953800;">  }</span></span>
<span class="line"><span style="color:#24292F;">&lt;/</span><span style="color:#116329;">script</span><span style="color:#24292F;">&gt;</span></span>
<span class="line"></span></code></pre></div><h3 id="渲染上下文相关源码分析" tabindex="-1"><a class="header-anchor" href="#渲染上下文相关源码分析" aria-hidden="true">#</a> 渲染上下文相关源码分析</h3><p>创建组件实例时生成渲染上下文。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// packages/runtime-core/src/component.ts@createComponentInstance</span></span>
<span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">createComponentInstance</span><span style="color:#24292F;">(){</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// ...</span></span>
<span class="line"><span style="color:#24292F;">  instance.ctx </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> { _: instance }</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// ...</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> instance</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>创建渲染上下文代理 <code>instance.proxy</code>，并使用 accessCache 属性代理访问缓存，因为每次代理访问数据都要经过多处数据源判断。</p><blockquote><p>源码位置： packages/runtime-core/src/componentPublicInstance.ts @PublicInstanceProxyHandlers</p></blockquote><p>缓存 key 和对应的数据源，能够直达访问，减少很多判断，性能提升。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// mountComponent =&gt; setupComponent =&gt; setupStatefulComponent</span></span>
<span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">setupStatefulComponent</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">instance</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentInternalInstance</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">isSSR</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">boolean</span></span>
<span class="line"><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Component</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> instance.type </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentOptions</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 0. create render proxy property access cache</span></span>
<span class="line"><span style="color:#24292F;">  instance.accessCache </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Object</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">create</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">null</span><span style="color:#24292F;">)</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 1. create public instance / render proxy</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// also mark it raw so it&#39;s never observed</span></span>
<span class="line"><span style="color:#24292F;">  instance.proxy </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">markRaw</span><span style="color:#24292F;">(</span><span style="color:#CF222E;">new</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Proxy</span><span style="color:#24292F;">(instance.ctx, PublicInstanceProxyHandlers))</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (__DEV__) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">exposePropsOnRenderContext</span><span style="color:#24292F;">(instance)</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 2. call setup()</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> { </span><span style="color:#0550AE;">setup</span><span style="color:#24292F;"> } </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> Component</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (setup) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 执行 setup ... </span></span>
<span class="line"><span style="color:#24292F;">  } </span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>执行渲染函数并应用渲染上下文。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">renderComponentRoot</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">instance</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentInternalInstance</span></span>
<span class="line"><span style="color:#24292F;">)</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">VNode</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#CF222E;">const</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#953800;">type</span><span style="color:#24292F;">: </span><span style="color:#0550AE;">Component</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">vnode</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">proxy</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">withProxy</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">props</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#953800;">propsOptions</span><span style="color:#24292F;">: [</span><span style="color:#0550AE;">propsOptions</span><span style="color:#24292F;">],</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">slots</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">attrs</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">emit</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">render</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">renderCache</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">data</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">setupState</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">ctx</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#0550AE;">inheritAttrs</span></span>
<span class="line"><span style="color:#24292F;">} </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> instance</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> result</span></span>
<span class="line"><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">prev</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">setCurrentRenderingInstance</span><span style="color:#24292F;">(instance)</span></span>
<span class="line"><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (__DEV__) {</span></span>
<span class="line"><span style="color:#24292F;"> accessedAttrs </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">false</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"><span style="color:#CF222E;">try</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> fallthroughAttrs</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (vnode.shapeFlag </span><span style="color:#CF222E;">&amp;</span><span style="color:#24292F;"> ShapeFlags.</span><span style="color:#0550AE;">STATEFUL_COMPONENT</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">   </span><span style="color:#6E7781;">// withProxy is a proxy with a different `has` trap only for</span></span>
<span class="line"><span style="color:#24292F;">   </span><span style="color:#6E7781;">// runtime-compiled render functions using `with` block.</span></span>
<span class="line"><span style="color:#24292F;">   </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">proxyToUse</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> withProxy </span><span style="color:#CF222E;">||</span><span style="color:#24292F;"> proxy</span></span>
<span class="line"><span style="color:#24292F;">   result </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">normalizeVNode</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">     render</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">call</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">       proxyToUse,</span></span>
<span class="line"><span style="color:#24292F;">       proxyToUse</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">       renderCache,</span></span>
<span class="line"><span style="color:#24292F;">       props,</span></span>
<span class="line"><span style="color:#24292F;">       setupState,</span></span>
<span class="line"><span style="color:#24292F;">       data,</span></span>
<span class="line"><span style="color:#24292F;">       ctx</span></span>
<span class="line"><span style="color:#24292F;">     )</span></span>
<span class="line"><span style="color:#24292F;">   )</span></span>
<span class="line"><span style="color:#24292F;">   fallthroughAttrs </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> attrs</span></span>
<span class="line"><span style="color:#24292F;"> } </span><span style="color:#CF222E;">else</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">   </span><span style="color:#6E7781;">// functional</span></span>
<span class="line"><span style="color:#24292F;">   </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">render</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> Component </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> </span><span style="color:#953800;">FunctionalComponent</span></span>
<span class="line"><span style="color:#24292F;">   </span></span>
<span class="line"><span style="color:#24292F;">   result </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">normalizeVNode</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">     render.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">&gt;</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span></span>
<span class="line"><span style="color:#24292F;">       </span><span style="color:#CF222E;">?</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">render</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">           props,</span></span>
<span class="line"><span style="color:#24292F;">           __DEV__</span></span>
<span class="line"><span style="color:#24292F;">             </span><span style="color:#CF222E;">?</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">                 </span><span style="color:#CF222E;">get</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">attrs</span><span style="color:#24292F;">() {</span></span>
<span class="line"><span style="color:#24292F;">                   </span><span style="color:#8250DF;">markAttrsAccessed</span><span style="color:#24292F;">()</span></span>
<span class="line"><span style="color:#24292F;">                   </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> attrs</span></span>
<span class="line"><span style="color:#24292F;">                 },</span></span>
<span class="line"><span style="color:#24292F;">                 slots,</span></span>
<span class="line"><span style="color:#24292F;">                 emit</span></span>
<span class="line"><span style="color:#24292F;">               }</span></span>
<span class="line"><span style="color:#24292F;">             </span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> { attrs, slots, emit }</span></span>
<span class="line"><span style="color:#24292F;">         )</span></span>
<span class="line"><span style="color:#24292F;">       </span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">render</span><span style="color:#24292F;">(props, </span><span style="color:#0550AE;">null</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">any</span><span style="color:#24292F;"> </span><span style="color:#6E7781;">/* we know it doesn&#39;t need it */</span><span style="color:#24292F;">)</span></span>
<span class="line"><span style="color:#24292F;">   )</span></span>
<span class="line"><span style="color:#24292F;"> }</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">} </span></span>
<span class="line"></span></code></pre></div><ol><li>参数传递方式，上面模板编译例子中经过模板编译的渲染函数即可通过参数 ctx 代理访问数据</li><li>this 绑定，在自定义的 render 里可通过 this 访问数据<div class="language-jsx ext-jsx"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">{</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#8250DF;">render</span><span style="color:#24292F;">() {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> &lt;</span><span style="color:#116329;">div</span><span style="color:#24292F;">&gt;{ </span><span style="color:#0550AE;">this</span><span style="color:#24292F;">.name }&lt;/</span><span style="color:#116329;">div</span><span style="color:#24292F;">&gt;</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div></li></ol><h3 id="proxy-和-withproxy" tabindex="-1"><a class="header-anchor" href="#proxy-和-withproxy" aria-hidden="true">#</a> proxy 和 withProxy</h3><p>在看 vue 源码过程发现组件属性上为什么有两个渲染上下文代理 proxy 和 withProxy。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">interface</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentInternalInstance</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// main proxy that serves as the public instance (`this`)</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">proxy</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentPublicInstance</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">/**</span></span>
<span class="line"><span style="color:#6E7781;">   * alternative proxy used only for runtime-compiled render functions using</span></span>
<span class="line"><span style="color:#6E7781;">   * `with` block</span></span>
<span class="line"><span style="color:#6E7781;">   * </span><span style="color:#CF222E;">@internal</span></span>
<span class="line"><span style="color:#6E7781;">   */</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">withProxy</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentPublicInstance</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// ...</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>withProxy 是针对动态模板编译的场景。</p><p>随手写了两个组件，一个是动态模板编译一个是 SFC 组件编译，并打印了其渲染函数。</p><p><img src="/assets/img/47baf14950ffeb8be704d559277b00b7ceda6ffc41a854e4a93bab241931c8f1.4c544977.png" alt="图 4"></p><p>使用模板 DSL 最大的一点就是限制用户写法，从而提供安全及性能。</p><blockquote><p>vue 的模板表达式都被放在沙盒中，只能访问一个受限的<a href="https://github.com/vuejs/vue-next/blob/master/packages/shared/src/globalsWhitelist.ts#L3" target="_blank" rel="noopener noreferrer">全局变量列表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，如 Math 和 Date。你不应该在模板表达式中试图访问用户定义的全局变量，就上面示例访问全局变量 history。</p></blockquote><p>但有一点让我感到困惑的是为什么两者编译后的代码不相同，一个通过作用域链一个通过原型链访问，理论上来说两者可达到同样的目的效果，那为什么不统一使用下面的方式？</p><p><strong>这里有个小技巧：看源码过程一般建议关注主线逻辑，像各种特殊情况可通过注释、commit message、issue 或者测试用例查看原由</strong>。</p><p>源码中模板表达式的处理逻辑：</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// packages/compiler-core/src/transforms/transformExpression.ts@processExpression</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6E7781;">// Important: since this function uses Node.js only dependencies, it should</span></span>
<span class="line"><span style="color:#6E7781;">// always be used with a leading !__BROWSER__ check so that it can be</span></span>
<span class="line"><span style="color:#6E7781;">// tree-shaken from the browser build.</span></span>
<span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">processExpression</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">node</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">SimpleExpressionNode</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">context</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">TransformContext</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// some expressions like v-slot props &amp; v-for aliases should be parsed as</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// function params</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">asParams</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">false</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// v-on handler values may contain multiple statements</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">asRawStatements</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">false</span></span>
<span class="line"><span style="color:#24292F;">)</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ExpressionNode</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (__BROWSER__) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (__DEV__) {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// simple in-browser validation (same logic in 2.x)</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#8250DF;">validateBrowserExpression</span><span style="color:#24292F;">(node, context, asParams, asRawStatements)</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> node</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// `__BROWSER__` 环境下，下面代码会被删除</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// ....</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">needPrefix</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">shouldPrefix</span><span style="color:#24292F;">(node, parent</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">, parentStack)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">//...</span></span>
<span class="line"></span></code></pre></div><p>正常本地 AOT 编译的情况下该函数会执行到 <code>shouldPrefix</code> 方法，该函数会根据全局变量白名单判断是否要添加 <code>_ctx.</code> 前缀。比如 history 是禁止的，那么就限制在 _ctx 的原型链上查找，否则可通过作用域链到全局查找。</p><p>但在线上浏览器中动态编译时，打包编译器代码会把包含 <code>@babel/parse</code> 代码给包含进去，这就导致整个 complie runtime 很大（有个相关 <a href="https://github.com/vuejs/vue-next/issues/2515" target="_blank" rel="noopener noreferrer">issue<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 讨论）。所以在 <code>__BROWSER__</code> 环境下通过 tree-shaking 删除代码，这样子表达式相当于不做处理直接返回。</p><p>那么如何限制 history ？就只能通过 <code>with</code> 限制作用链查找。对于使用 with 块运行时编译的渲染函数，渲染上下文的代理是 RuntimeCompiledPublicInstanceProxyHandlers。它是在之前渲染上下文代理 PublicInstanceProxyHandlers 的基础上进行的扩展，主要对 has 函数的实现做了优化：</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// packages/runtime-core/src/componentPublicInstance.ts@RuntimeCompiledPublicInstanceProxyHandlers</span></span>
<span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">RuntimeCompiledPublicInstanceProxyHandlers</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#6E7781;">/*#__PURE__*/</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">extend</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">  {},</span></span>
<span class="line"><span style="color:#24292F;">  PublicInstanceProxyHandlers,</span></span>
<span class="line"><span style="color:#24292F;">  {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">get</span><span style="color:#24292F;">(</span><span style="color:#953800;">target</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentRenderContext</span><span style="color:#24292F;">, </span><span style="color:#953800;">key</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">string</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// fast path for unscopables when using `with` block</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> ((key </span><span style="color:#CF222E;">as</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">any</span><span style="color:#24292F;">) </span><span style="color:#CF222E;">===</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Symbol</span><span style="color:#24292F;">.unscopables) {</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#CF222E;">return</span></span>
<span class="line"><span style="color:#24292F;">      }</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> PublicInstanceProxyHandlers.</span><span style="color:#8250DF;">get</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">(target, key, target)</span></span>
<span class="line"><span style="color:#24292F;">    },</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">has</span><span style="color:#24292F;">(</span><span style="color:#953800;">_</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentRenderContext</span><span style="color:#24292F;">, </span><span style="color:#953800;">key</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">string</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">has</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> key[</span><span style="color:#0550AE;">0</span><span style="color:#24292F;">] </span><span style="color:#CF222E;">!==</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&#39;_&#39;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">!</span><span style="color:#8250DF;">isGloballyWhitelisted</span><span style="color:#24292F;">(key)</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (__DEV__ </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">!</span><span style="color:#24292F;">has </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> PublicInstanceProxyHandlers.</span><span style="color:#8250DF;">has</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">(_, key)) {</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#8250DF;">warn</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">          </span><span style="color:#0A3069;">`Property ${</span><span style="color:#0550AE;">JSON</span><span style="color:#0A3069;">.</span><span style="color:#0550AE;">stringify</span><span style="color:#0A3069;">(</span></span>
<span class="line"><span style="color:#0A3069;">            </span><span style="color:#24292F;">key</span></span>
<span class="line"><span style="color:#0A3069;">          )</span><span style="color:#0A3069;">} should not start with _ which is a reserved prefix for Vue internals.`</span></span>
<span class="line"><span style="color:#24292F;">        )</span></span>
<span class="line"><span style="color:#24292F;">      }</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> has</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">)</span></span>
<span class="line"></span></code></pre></div><p>这里如果 key 以 _ 开头，或者 key 在全局变量的白名单内，则 has 为 false，此时则直接命中警告，不用再进行之前那一系列的判断了。</p><h2 id="异步更新机制" tabindex="-1"><a class="header-anchor" href="#异步更新机制" aria-hidden="true">#</a> 异步更新机制</h2><p>当响应式数据发生变化时并不会立即更新视图，而是将视图更新任务派发给<strong>调度器</strong>调度执行。也就是说 vue 的视图更新是异步的，这是因为当你有多个响应式数据修改的时候，不可能每修改一个就同步一次更新操作，而是将所有的更新任务都缓冲到下一个 tick 中去执行。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// packages/runtime-core/src/scheduler.ts</span></span>
<span class="line"><span style="color:#6E7781;">// ...</span></span>
<span class="line"><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">effect</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">new</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">ReactiveEffect</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">      componentUpdateFn, </span><span style="color:#6E7781;">// 组件渲染函数</span></span>
<span class="line"><span style="color:#24292F;">      () </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">queueJob</span><span style="color:#24292F;">(instance.update), </span><span style="color:#6E7781;">// 放进任务队列</span></span>
<span class="line"><span style="color:#24292F;">      instance.scope </span><span style="color:#6E7781;">// track it in component&#39;s effect scope</span></span>
<span class="line"><span style="color:#24292F;">    )</span></span>
<span class="line"><span style="color:#6E7781;">//...</span></span>
<span class="line"></span></code></pre></div><p>视图更新任务都会放进异步队列。但为了保证渲染一致性，vue 根据渲染前后分为了不同队列：</p><ul><li>pendingPreFlushCbs（pre queue）</li><li>queue（render queue）</li><li>pendingPostFlushCbs（post queue）</li></ul><p>vue3 为开发者提供了方便的可变数据功能，却复杂了自己内部实现。相比 vue2 时期直接将更新任务放到单个异步队列而言，vue3 则是多优先级队列 + 调度机制，因为响应式触发的多个观察者需要保证他们按照预期效果执行就需要进行调度任务。</p><p>响应式数据发生变化时会触发三类任务分别是 watcher、render、effect。</p><p><img src="/assets/img/0fbc7dac1c4b4892205a65308aa3cdc7e82cb3aaf09fa57e1125ccfc7058d817.79a3a844.png" alt="图 16"></p><p>其中 effect 是底层响应式副作用 api 生成的，是响应式同步触发；而 render 和 watcher 是 effect 基础上实现的，是给开发者们优先使用的，并且接入调度机制中。</p><p>render 任务是存放进 render queue 中，watcher 则可根据属性控制：</p><ul><li>pre 对应 pre queue</li><li>post 对应 post queue</li><li>sync 直接同步执行</li></ul><p>了解了任务类型及对应的任务队列后，我们再了解 vue 是如何异步更新，其实很简单： <strong>在同一个 tick 中对触发的 watcher、render 任务用对应的任务队列进行缓冲收集并且在运行时环境创建一个异步任务用于负责执行这些更新任务</strong>。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// queueJob 将异步更新任务插入到 render queue 队列中</span></span>
<span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">queueJob</span><span style="color:#24292F;">(</span><span style="color:#953800;">job</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">SchedulerJob</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 省略...</span></span>
<span class="line"><span style="color:#24292F;">  ) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 插入队列</span></span>
<span class="line"><span style="color:#24292F;">    queue.</span><span style="color:#8250DF;">push</span><span style="color:#24292F;">(job)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">queueFlush</span><span style="color:#24292F;">()  </span><span style="color:#6E7781;">// 向运行时环境发起一个异步任务</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">queueFlush</span><span style="color:#24292F;">() {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 防止重复触发</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">isFlushing </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">!</span><span style="color:#24292F;">isFlushPending) {</span></span>
<span class="line"><span style="color:#24292F;">    isFlushPending </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">true</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 发起异步任务</span></span>
<span class="line"><span style="color:#24292F;">    currentFlushPromise </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> resolvedPromise.</span><span style="color:#8250DF;">then</span><span style="color:#24292F;">(flushJobs)</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">resolvedPromise</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">Promise</span><span style="color:#24292F;">&lt;</span><span style="color:#0550AE;">any</span><span style="color:#24292F;">&gt; </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Promise</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">resolve</span><span style="color:#24292F;">()</span></span>
<span class="line"></span></code></pre></div><p>这里有点一跟 vue2 不同的是：vue3 中直接只使用 Promise 去做异步任务，并没有像 vue2 去做兼容降级方案。能够支持 vue3 的环境，也就是支持 proxy api，大体基本都支持 Promise。</p><h3 id="调度细节" tabindex="-1"><a class="header-anchor" href="#调度细节" aria-hidden="true">#</a> 调度细节</h3><p>接下来看看 flushJobs 是如何执行更新任务以及一些细节问题。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">flushJobs</span><span style="color:#24292F;">(</span><span style="color:#953800;">seen</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#953800;">CountMap</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  isFlushPending </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">false</span></span>
<span class="line"><span style="color:#24292F;">  isFlushing </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">true</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (__DEV__) {</span></span>
<span class="line"><span style="color:#24292F;">    seen </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> seen </span><span style="color:#CF222E;">||</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">new</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Map</span><span style="color:#24292F;">()</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 执行 pre queue</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#8250DF;">flushPreFlushCbs</span><span style="color:#24292F;">(seen)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// Sort queue before flush.</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// This ensures that:</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 1. Components are updated from parent to child. (because parent is always</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">//    created before the child so its render effect will have smaller</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">//    priority number)</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 2. If a component is unmounted during a parent component&#39;s update,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">//    its update can be skipped.</span></span>
<span class="line"><span style="color:#24292F;">  queue.</span><span style="color:#8250DF;">sort</span><span style="color:#24292F;">((</span><span style="color:#953800;">a</span><span style="color:#24292F;">, </span><span style="color:#953800;">b</span><span style="color:#24292F;">) </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">getId</span><span style="color:#24292F;">(a) </span><span style="color:#CF222E;">-</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">getId</span><span style="color:#24292F;">(b))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// 执行 render queue</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">try</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">for</span><span style="color:#24292F;"> (flushIndex </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">0</span><span style="color:#24292F;">; flushIndex </span><span style="color:#CF222E;">&lt;</span><span style="color:#24292F;"> queue.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;">; flushIndex</span><span style="color:#CF222E;">++</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">job</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> queue[flushIndex]</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (job </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> job.active </span><span style="color:#CF222E;">!==</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">false</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (__DEV__ </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">checkRecursiveUpdates</span><span style="color:#24292F;">(seen</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">, job)) {</span></span>
<span class="line"><span style="color:#24292F;">          </span><span style="color:#CF222E;">continue</span></span>
<span class="line"><span style="color:#24292F;">        }</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#6E7781;">// console.log(`running:`, job.id)</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#8250DF;">callWithErrorHandling</span><span style="color:#24292F;">(job, </span><span style="color:#0550AE;">null</span><span style="color:#24292F;">, ErrorCodes.</span><span style="color:#0550AE;">SCHEDULER</span><span style="color:#24292F;">)</span></span>
<span class="line"><span style="color:#24292F;">      }</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">  } </span><span style="color:#CF222E;">finally</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">    flushIndex </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">0</span></span>
<span class="line"><span style="color:#24292F;">    queue.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">0</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 执行 post queue</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">flushPostFlushCbs</span><span style="color:#24292F;">(seen)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">    isFlushing </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">false</span></span>
<span class="line"><span style="color:#24292F;">    currentFlushPromise </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// some postFlushCb queued jobs!</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// keep flushing until it drains.</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span></span>
<span class="line"><span style="color:#24292F;">      queue.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">||</span></span>
<span class="line"><span style="color:#24292F;">      pendingPreFlushCbs.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">||</span></span>
<span class="line"><span style="color:#24292F;">      pendingPostFlushCbs.</span><span style="color:#0550AE;">length</span></span>
<span class="line"><span style="color:#24292F;">    ) {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#8250DF;">flushJobs</span><span style="color:#24292F;">(seen)</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>从上看出</p><ol><li>队列的执行顺序依次为 pre queue、render queue、post queue</li><li>render queue 执行前需要排序，为什么？</li></ol><p>这主要跟 vue 组件的渲染机制有关，一个 vue 组件发生更新有两种情况：</p><ul><li>依赖的响应性 state 发生修改</li><li>自身 props 发生修改</li></ul><p>props 是由父组件传入，是在 render 过程中。当 props 发生改，子组件也会发生更新，<strong>整个组件树的创建更新顺序都是从父到子</strong>。</p><p>但有一种情况，就是父子组件刚好依赖到同一个 state，这会导致 render queue 里同时存在父子组件的 render 任务，更坏的情况是子 render 任务可能排在父 render 前。</p><p><img src="/assets/img/0f8bc010ae31abd663a9a31301c36e79ac2b0165e3f52274b53bae1dd0268173.fda3fe89.png" alt="图 12"></p><p>子 render 任务本来就会更新子组件，而父 render 任务可能修改子组件的 props 同样也可能会导致子组件更新，也就是说 父 rennder 任务其实可能包含子 render 任务，那这样就会导致子组件在同一个 tick 中 render 两次。</p><p>源码中先进行父子排序，先执行父 render 任务，并且在更新子组件之前先能够 <code>invalidateJob(instance.update)</code> 把队列中的子 render 任务删除，这样做就不会重复更新子组件。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">updateComponent</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> (</span><span style="color:#953800;">n1</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">VNode</span><span style="color:#24292F;">, </span><span style="color:#953800;">n2</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">VNode</span><span style="color:#24292F;">, </span><span style="color:#953800;">optimized</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">boolean</span><span style="color:#24292F;">) </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">instance</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> (n2.component </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> n1.component)</span><span style="color:#CF222E;">!</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span><span style="color:#8250DF;">shouldUpdateComponent</span><span style="color:#24292F;">(n1, n2, optimized)) {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// normal update</span></span>
<span class="line"><span style="color:#24292F;">      instance.next </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> n2</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// in case the child component is also queued, remove it to avoid</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// double updating the same child component in the same flush.</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#8250DF;">invalidateJob</span><span style="color:#24292F;">(instance.update)</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// instance.update is the reactive effect.</span></span>
<span class="line"><span style="color:#24292F;">      instance.</span><span style="color:#8250DF;">update</span><span style="color:#24292F;">()</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">    } </span><span style="color:#CF222E;">else</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">// no update needed. just copy over properties</span></span>
<span class="line"><span style="color:#24292F;">      n2.component </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> n1.component</span></span>
<span class="line"><span style="color:#24292F;">      n2.el </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> n1.el</span></span>
<span class="line"><span style="color:#24292F;">      instance.vnode </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> n2</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"></span></code></pre></div><p>接下来看，当一个组件依赖的多个状态同时发生变更时：</p><p><img src="/assets/img/c6bc7c326a444056906400fd1f0b15c4b614d7e91f756d5c3f55191ec1f2e87e.0ede5959.png" alt="图 13"></p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">queueJob</span><span style="color:#24292F;">(</span><span style="color:#953800;">job</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">SchedulerJob</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span></span>
<span class="line"><span style="color:#24292F;">    (</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">queue.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">||</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">!</span><span style="color:#24292F;">queue.</span><span style="color:#8250DF;">includes</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">        job,</span></span>
<span class="line"><span style="color:#24292F;">        isFlushing </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> job.allowRecurse </span><span style="color:#CF222E;">?</span><span style="color:#24292F;"> flushIndex </span><span style="color:#CF222E;">+</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> flushIndex</span></span>
<span class="line"><span style="color:#24292F;">      )) </span><span style="color:#CF222E;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292F;">    job </span><span style="color:#CF222E;">!==</span><span style="color:#24292F;"> currentPreFlushParentJob</span></span>
<span class="line"><span style="color:#24292F;">  ) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (job.id </span><span style="color:#CF222E;">==</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">      queue.</span><span style="color:#8250DF;">push</span><span style="color:#24292F;">(job)</span></span>
<span class="line"><span style="color:#24292F;">    } </span><span style="color:#CF222E;">else</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">      queue.</span><span style="color:#8250DF;">splice</span><span style="color:#24292F;">(</span><span style="color:#8250DF;">findInsertionIndex</span><span style="color:#24292F;">(job.id), </span><span style="color:#0550AE;">0</span><span style="color:#24292F;">, job)</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">queueFlush</span><span style="color:#24292F;">()</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>其中</p><ol><li>在执行清空所有任务队列前先去重。（这时还没 flushing， flushIndex 为 0，意味着即整个队列去重）</li><li>但执行队列任务过程又可以根据 <code>job.allowRecurse</code> 条件插入任务、或者重复任务，这是为什么？</li></ol><p><img src="/assets/img/0af1f873ecd39740f507a6003defe704cdd24ffbc201c2077d3c92af13b0d297.b05f4263.png" alt="图 14"></p><p>图上有两处循环：</p><p>在执行 pre queue 中的 watcher 时，watcher 可能会修改 state，产生新的 watcher 插入 pre queue 中，所以必须循环处理完 pre queue 中任务，保证在执行 render 后视图数据一致。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">flushPreFlushCbs</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">seen</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#953800;">CountMap</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">parentJob</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">SchedulerJob</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span></span>
<span class="line"><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (pendingPreFlushCbs.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">    currentPreFlushParentJob </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> parentJob </span><span style="color:#6E7781;">// 先忽略</span></span>
<span class="line"><span style="color:#24292F;">    activePreFlushCbs </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> [</span><span style="color:#CF222E;">...new</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Set</span><span style="color:#24292F;">(pendingPreFlushCbs)]</span></span>
<span class="line"><span style="color:#24292F;">    pendingPreFlushCbs.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">0</span></span>
<span class="line"><span style="color:#24292F;">    </span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">for</span><span style="color:#24292F;"> (</span></span>
<span class="line"><span style="color:#24292F;">      preFlushIndex </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">0</span><span style="color:#24292F;">;</span></span>
<span class="line"><span style="color:#24292F;">      preFlushIndex </span><span style="color:#CF222E;">&lt;</span><span style="color:#24292F;"> activePreFlushCbs.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;">;</span></span>
<span class="line"><span style="color:#24292F;">      preFlushIndex</span><span style="color:#CF222E;">++</span></span>
<span class="line"><span style="color:#24292F;">    ) {</span></span>
<span class="line"><span style="color:#24292F;">      </span></span>
<span class="line"><span style="color:#24292F;">      activePreFlushCbs[preFlushIndex]()</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">    activePreFlushCbs </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span></span>
<span class="line"><span style="color:#24292F;">    preFlushIndex </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">0</span></span>
<span class="line"><span style="color:#24292F;">    currentPreFlushParentJob </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// recursively flush until it drains</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 递归处理</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">flushPreFlushCbs</span><span style="color:#24292F;">(seen, parentJob)</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>在执行 render 任务时，这时 props 的改变可能会触发子组件的 watcher，在渲染子组件前同样必须先清空 pre queue。同时要注意防止往 render queue 中插入子 render 任务，因为当前的 render 任务包含了子 render 任务要执行。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// packages/runtime-core/src/renderer.ts</span></span>
<span class="line"><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">updateComponentPreRender</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> (</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#953800;">instance</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentInternalInstance</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#953800;">nextVNode</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">VNode</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#953800;">optimized</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">boolean</span></span>
<span class="line"><span style="color:#24292F;">) </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#6E7781;">// 省略代码...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#6E7781;">// props update may have triggered pre-flush watchers.</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#6E7781;">// flush them before the render update.</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#6E7781;">// 渲染前清空 pre queue</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#6E7781;">// 第二参数记录当前调用栈中的父任务，此时即为子 render</span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#8250DF;">flushPreFlushCbs</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">undefined</span><span style="color:#24292F;">, instance.update)</span></span>
<span class="line"><span style="color:#24292F;"> </span></span>
<span class="line"><span style="color:#24292F;"> </span><span style="color:#6E7781;">// ...</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">flushPreFlushCbs</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">seen</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#953800;">CountMap</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">parentJob</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">SchedulerJob</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">null</span></span>
<span class="line"><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (pendingPreFlushCbs.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 全局变量标记</span></span>
<span class="line"><span style="color:#24292F;">    currentPreFlushParentJob </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> parentJob</span></span>
<span class="line"><span style="color:#24292F;">    </span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// ... 任务执行</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// recursively flush until it drains</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">flushPreFlushCbs</span><span style="color:#24292F;">(seen, parentJob)</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">queueJob</span><span style="color:#24292F;">(</span><span style="color:#953800;">job</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">SchedulerJob</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span></span>
<span class="line"><span style="color:#24292F;">    (</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">queue.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">||</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">!</span><span style="color:#24292F;">queue.</span><span style="color:#8250DF;">includes</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">        job,</span></span>
<span class="line"><span style="color:#24292F;">        isFlushing </span><span style="color:#CF222E;">&amp;&amp;</span><span style="color:#24292F;"> job.allowRecurse </span><span style="color:#CF222E;">?</span><span style="color:#24292F;"> flushIndex </span><span style="color:#CF222E;">+</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> flushIndex</span></span>
<span class="line"><span style="color:#24292F;">      )) </span><span style="color:#CF222E;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 任务对比，防止重复插入</span></span>
<span class="line"><span style="color:#24292F;">    job </span><span style="color:#CF222E;">!==</span><span style="color:#24292F;"> currentPreFlushParentJob</span></span>
<span class="line"><span style="color:#24292F;">  ) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>但是我们同样也需要注意个问题：上面虽然解决了子 render 重复的问题，但 watcher 中可能会<strong>修改到了父组件的依赖</strong>！</p><p>一个 render 任务执行的时候有两个重要过程：</p><ol><li>创建新的 subTree</li><li>diff 新旧 subTree</li></ol><p>在 patch 过程，子组件 props 发生了修改而触发的 watcher 修改到父组件依赖状态。那么这时父 render 过程生成的新的 subTree 其实已经不是最新状态的映射了，导致最后视图不一致，所以需要个<strong>弥补机制</strong>，父组件再 render 一次。</p><p><img src="/assets/img/90c2621f65c020b6b2695cec35bdb6bf2fe9a74acd9a81bc4d5ae44e2b975f9a.3138786f.png" alt="图 15"></p><p>queueJob 中 <code>isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex</code> 里 <code>flushIndex + 1</code> 使得能够插入重复 render 任务。</p><blockquote><p>这里有个 <a href="https://github.com/vuejs/vue-next/issues/1801" target="_blank" rel="noopener noreferrer">issue<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 上面的示例可以去调试看看。</p></blockquote><h2 id="reactiveeffect-allowrecurse" tabindex="-1"><a class="header-anchor" href="#reactiveeffect-allowrecurse" aria-hidden="true">#</a> <a href="#Effect.allowRecurse">ReactiveEffect.allowRecurse</a></h2><p>ReactiveEffect.allowRecurse 并没有过多的注释，但我们可以从 <code>packages/runtime-core/src/scheduler.ts</code> 中发现相关注释，其实 Render ReactiveEffect 就是 SchedulerJob。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">interface</span><span style="color:#24292F;"> </span><span style="color:#953800;">SchedulerJob</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">extends</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">Function</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">id</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">number</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">active</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">boolean</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">computed</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">boolean</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">/**</span></span>
<span class="line"><span style="color:#6E7781;">   * Indicates whether the effect is allowed to recursively trigger itself</span></span>
<span class="line"><span style="color:#6E7781;">   * when managed by the scheduler.</span></span>
<span class="line"><span style="color:#6E7781;">   *</span></span>
<span class="line"><span style="color:#6E7781;">   * By default, a job cannot trigger itself because some built-in method calls,</span></span>
<span class="line"><span style="color:#6E7781;">   * e.g. Array.prototype.push actually performs reads as well (#1740) which</span></span>
<span class="line"><span style="color:#6E7781;">   * can lead to confusing infinite loops.</span></span>
<span class="line"><span style="color:#6E7781;">   * The allowed cases are component update functions and watch callbacks.</span></span>
<span class="line"><span style="color:#6E7781;">   * Component update functions may update child component props, which in turn</span></span>
<span class="line"><span style="color:#6E7781;">   * trigger flush: &quot;pre&quot; watch callbacks that mutates state that the parent</span></span>
<span class="line"><span style="color:#6E7781;">   * relies on (#1801). Watch callbacks doesn&#39;t track its dependencies so if it</span></span>
<span class="line"><span style="color:#6E7781;">   * triggers itself again, it&#39;s likely intentional and it is the user&#39;s</span></span>
<span class="line"><span style="color:#6E7781;">   * responsibility to perform recursive state mutation that eventually</span></span>
<span class="line"><span style="color:#6E7781;">   * stabilizes (#1727).</span></span>
<span class="line"><span style="color:#6E7781;">   */</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">allowRecurse</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">boolean</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">/**</span></span>
<span class="line"><span style="color:#6E7781;">   * Attached by renderer.ts when setting up a component&#39;s render effect</span></span>
<span class="line"><span style="color:#6E7781;">   * Used to obtain component information when reporting max recursive updates.</span></span>
<span class="line"><span style="color:#6E7781;">   * dev only.</span></span>
<span class="line"><span style="color:#6E7781;">   */</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">ownerInstance</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#953800;">ComponentInternalInstance</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>ReactiveEffect 创建实例时其 allowRecurse 是为 undefined，可以说是 false，在同一 effect 下是不会触发重复递归的。</p><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">triggerEffects</span><span style="color:#24292F;">(</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">dep</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">Dep</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">|</span><span style="color:#24292F;"> </span><span style="color:#953800;">ReactiveEffect</span><span style="color:#24292F;">[],</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#953800;">debuggerEventExtraInfo</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> </span><span style="color:#953800;">DebuggerEventExtraInfo</span></span>
<span class="line"><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// spread into array for stabilization</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">for</span><span style="color:#24292F;"> (</span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">effect</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">of</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">isArray</span><span style="color:#24292F;">(dep) </span><span style="color:#CF222E;">?</span><span style="color:#24292F;"> dep </span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> [</span><span style="color:#CF222E;">...</span><span style="color:#24292F;">dep]) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#6E7781;">// 防止 effect 重复调用</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (effect </span><span style="color:#CF222E;">!==</span><span style="color:#24292F;"> activeEffect </span><span style="color:#CF222E;">||</span><span style="color:#24292F;"> effect.allowRecurse) {</span></span>
<span class="line"><span style="color:#24292F;">      </span><span style="color:#6E7781;">//...</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">  }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>下面例子中，effect 中修改 test 值，但副作用只执行了一次。</p><p><img src="/assets/img/a631cc0e1963f36f38f2426fc6dae0f9a7e799bf70325b35062b05462f495af8.58542777.png" alt="图 11"></p><p>而 <strong>render、watcher 是可以重复递归</strong>，其中可重复 render 是有场景需求，而watcher 则是不想违背模式，如果 watcher 里修改数据重新触发了 watcher，那更多是用户的一种责任行为。</p><h2 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick" aria-hidden="true">#</a> nextTick</h2><div class="language-typescript ext-ts"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">export</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">nextTick</span><span style="color:#24292F;">&lt;</span><span style="color:#953800;">T</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">void</span><span style="color:#24292F;">&gt;(</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#0550AE;">this</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">T</span><span style="color:#24292F;">,</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#8250DF;">fn</span><span style="color:#CF222E;">?:</span><span style="color:#24292F;"> (</span><span style="color:#0550AE;">this</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">T</span><span style="color:#24292F;">) </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">void</span></span>
<span class="line"><span style="color:#24292F;">)</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">Promise</span><span style="color:#24292F;">&lt;</span><span style="color:#0550AE;">void</span><span style="color:#24292F;">&gt; {</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">p</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> currentFlushPromise </span><span style="color:#CF222E;">||</span><span style="color:#24292F;"> resolvedPromise</span></span>
<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> fn </span><span style="color:#CF222E;">?</span><span style="color:#24292F;"> p.</span><span style="color:#8250DF;">then</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">this</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">?</span><span style="color:#24292F;"> fn.</span><span style="color:#8250DF;">bind</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">this</span><span style="color:#24292F;">) </span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> fn) </span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> p</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p>使用 promise 链式调用，保证 nextTick 的任务在异步更新任务后执行，这样某些插件就可以获得更新后的 DOM。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ol><li>响应式渲染机制：将组件渲染封装成渲染副作用，收集响应式依赖，异步调度更新。</li><li>vue 的异步更新机制：使用队列缓存更新任务，在事件循环中安排一个异步任务执行队列中所有任务。</li><li>异步更新防止重复渲染、保证单向更新。</li><li>单向数据流原则：组件树的更新过程是自顶向下，如果发生逆向数据流修改，会导致当前渲染的数据和视图映射不一致，需要重复多一次渲染。</li></ol></div><!----></article></div><footer class="footer footer-center p-4 bg-base-300 text-base-content opacity-60"><div><p>©2017-2021 laoergege.cn. All right reserved. </p><p><a href="https://beian.miit.gov.cn" target="_blank" class="link link-hover">粤ICP备2022020679号</a></p></div></footer><!--]--><!----><!--]--></div>
    <script src="/assets/js/runtime~app.7d4bd660.js" defer></script><script src="/assets/js/5838.13a569e5.js" defer></script><script src="/assets/js/app.7e792774.js" defer></script>
</body>

</html>