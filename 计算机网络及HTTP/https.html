<!DOCTYPE html>
<html lang="zh-CN" data-theme="cupcake">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.46">
    <link rel="manifest" href="/site.webmanifest.json"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><title>HTTPS | </title><meta name="description" content="Just For Fun">
    <link rel="preload" href="/assets/js/runtime~app.7d4bd660.js" as="script"><link rel="preload" href="/assets/css/styles.1c65b737.css" as="style"><link rel="preload" href="/assets/js/5838.13a569e5.js" as="script"><link rel="preload" href="/assets/js/app.7e792774.js" as="script"><link rel="prefetch" href="/assets/js/v-03fc2322.47d94022.js"><link rel="prefetch" href="/assets/js/v-ba2c1988.3632b5e0.js"><link rel="prefetch" href="/assets/js/v-fd8e5af2.a9cafb88.js"><link rel="prefetch" href="/assets/js/v-5a071f34.190f1fdc.js"><link rel="prefetch" href="/assets/js/v-317472f1.a3c9dba2.js"><link rel="prefetch" href="/assets/js/v-560b844b.09f8a065.js"><link rel="prefetch" href="/assets/js/v-85bc3e4c.27575d9e.js"><link rel="prefetch" href="/assets/js/v-4835f72d.209f9a9b.js"><link rel="prefetch" href="/assets/js/v-6f2abf9c.c6a52b82.js"><link rel="prefetch" href="/assets/js/v-32c68258.46247de2.js"><link rel="prefetch" href="/assets/js/v-04983e79.ae40370a.js"><link rel="prefetch" href="/assets/js/v-7269d92e.00653b56.js"><link rel="prefetch" href="/assets/js/v-54e51afe.e3f20358.js"><link rel="prefetch" href="/assets/js/v-5fbdabee.afcc17b5.js"><link rel="prefetch" href="/assets/js/v-928f5a14.0a4a3dc4.js"><link rel="prefetch" href="/assets/js/v-88c7f226.529f6212.js"><link rel="prefetch" href="/assets/js/v-5e99732b.68dd2407.js"><link rel="prefetch" href="/assets/js/v-2fc78b4d.97b37f50.js"><link rel="prefetch" href="/assets/js/v-d99bba28.2cf82742.js"><link rel="prefetch" href="/assets/js/v-bee2f4a8.f072eb83.js"><link rel="prefetch" href="/assets/js/v-57ad8616.44af159f.js"><link rel="prefetch" href="/assets/js/v-f701b528.aa7f8f17.js"><link rel="prefetch" href="/assets/js/v-093d016d.bc725dd1.js"><link rel="prefetch" href="/assets/js/v-06ed95cc.0db5595a.js"><link rel="prefetch" href="/assets/js/v-01b20944.db789013.js"><link rel="prefetch" href="/assets/js/v-137d7552.50039c10.js"><link rel="prefetch" href="/assets/css/5045.styles.72ac531f.css"><link rel="prefetch" href="/assets/js/v-631fc68a.80740d81.js"><link rel="prefetch" href="/assets/js/v-8b5f7690.191ba9a3.js"><link rel="prefetch" href="/assets/js/v-530f22f6.f8e361fa.js"><link rel="prefetch" href="/assets/js/v-be2646cc.549f65bf.js"><link rel="prefetch" href="/assets/js/v-75e44f07.2f8601c3.js"><link rel="prefetch" href="/assets/js/v-c2504efe.28c55f92.js"><link rel="prefetch" href="/assets/js/v-5bc51cd9.b23c2caa.js"><link rel="prefetch" href="/assets/js/5956.f176ea33.js"><link rel="prefetch" href="/assets/js/v-6dc8e518.a8181c32.js"><link rel="prefetch" href="/assets/js/v-568d3b89.483d19f1.js"><link rel="prefetch" href="/assets/js/v-743faa02.3247db36.js"><link rel="prefetch" href="/assets/js/v-d52c6cc0.34d4b256.js"><link rel="prefetch" href="/assets/js/v-78263bfa.b7cb21e4.js"><link rel="prefetch" href="/assets/js/v-199de1f8.16ad6f91.js"><link rel="prefetch" href="/assets/js/v-30078430.3079f1d2.js"><link rel="prefetch" href="/assets/js/v-240dbb06.02e786fb.js"><link rel="prefetch" href="/assets/js/v-7a102f72.94a1b7e7.js"><link rel="prefetch" href="/assets/js/v-1402111c.9dc8cc11.js"><link rel="prefetch" href="/assets/js/v-f2bbc8da.fc4d9aa5.js"><link rel="prefetch" href="/assets/js/v-b0176dc2.b994ff0c.js"><link rel="prefetch" href="/assets/js/4644.1787b6ff.js"><link rel="prefetch" href="/assets/js/v-a5da5a08.cc633de8.js"><link rel="prefetch" href="/assets/js/v-acadbc84.800a32fa.js"><link rel="prefetch" href="/assets/js/v-a270a8ca.ea9c331c.js"><link rel="prefetch" href="/assets/js/v-a9440b46.63ee3544.js"><link rel="prefetch" href="/assets/js/6929.46233b49.js"><link rel="prefetch" href="/assets/js/9840.789f773b.js"><link rel="prefetch" href="/assets/js/v-9f06f78c.ff18832e.js"><link rel="prefetch" href="/assets/js/9870.c84a31ac.js"><link rel="prefetch" href="/assets/js/v-8daa1a0e.8245b191.js"><link rel="prefetch" href="/sw.js"><link rel="prefetch" href="/assets/css/3859.styles.7057c730.css">
    <link rel="stylesheet" href="/assets/css/styles.1c65b737.css">
</head>

<body>
    <div id="app"><!--[--><!--[--><div class="navbar sticky top-0 z-10"><a href="/" class=""><label class="btn btn-circle avatar"><div class="rounded-full ring ring-white shadow-2xl no-zoom"><img src="/avatar.webp"></div></label></a></div><div class="min-h-screen flex justify-center flex-col items-center"><article class="article w-full sm:w-3/4 lg:w-2/3 p-4" data-theme="cupcake"><div class="sm:max-w-full pb-12 prose sm:prose-sm md:prose-lg dark:prose-invert"><h1 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h1><p>https 与 http 相比较</p><ul><li>在 HTTP 协议栈中引入安全协议层（对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作）</li><li>端口由默认的 80 改为 443</li></ul><p><img src="/assets/img/266e6a36239b598f1baa5333f52f6c41503c66538440fbea035c44f3f386306e.629f3cd0.png" alt="图 9"></p><p>SSL/TLS 为 http 增加了四个安全特性：</p><ul><li>机密性，只能由可信的人访问，对其他人是不可见</li><li>完整性，数据在传输过程中没有被篡改</li><li>身份认证，确认对方的真实身份</li><li>不可否认，也叫不可抵赖。</li></ul><h2 id="ssl-tls" tabindex="-1"><a class="header-anchor" href="#ssl-tls" aria-hidden="true">#</a> SSL/TLS</h2><p>SSL 即安全套接层（Secure Sockets Layer），后改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。到目前为止，应用的最广泛的 TLS 是 1.2。</p><p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p><blockquote><p>OpenSSL 是著名的开源密码学程序库和工具包，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等</p></blockquote><h3 id="加密套件" tabindex="-1"><a class="header-anchor" href="#加密套件" aria-hidden="true">#</a> 加密套件</h3><p>TLS/SSL 采用<strong>多种先进的加密技术保证通信安全</strong>，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件），密码套件命名非常规范，格式很固定。基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”。比如</p><p>“TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256”：</p><p>握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证（摘要认证）和伪随机函数产生随机数。</p><h2 id="https-安全原理" tabindex="-1"><a class="header-anchor" href="#https-安全原理" aria-hidden="true">#</a> https 安全原理</h2><p>因为 http 的内容是明文传输的，明文数据会经过“中间人”，容易被篡改，而 https 对明文数据进行了加密，使用了混合加密的方式，即对称加密和非对称加密的组合使用。</p><h3 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h3><p>通信双方都各自持有同一个密钥，这样就可以加密解密，且别人不知道。</p><p><img src="images/0c5cacbaa052f909ca632cbffc328b3e279878bced93a24db38a622927341110.png" alt="图 11"></p><p>但 http 是明文传输，那么如何把密钥安全地传递给对方？</p><h3 id="非对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a> 非对称加密</h3><p>非对称加密，使用两把密钥：公钥、私钥，公钥可以公开给任何人使用，而私钥必须严格保密，外部使用公钥加密的内容只能由私钥解开。</p><p><img src="images/f13246de24c73a99f530ed7ca59599d0d363104889cdb3bf108251f36fb69f30.png" alt="图 12"></p><p>服务器会将其中的一个公钥通过明文的形式发送给浏览器，浏览器通过公钥加密的内容只有服务器才能解密看到。</p><h3 id="混合加密" tabindex="-1"><a class="header-anchor" href="#混合加密" aria-hidden="true">#</a> 混合加密</h3><p>混合加密，简单说通信双方通过非对称加密协商出一个用于对称加密的密钥，因为<strong>非对称加密算法非常耗时，而对称加密快很多</strong>，所以使用非对称加密方式传输对称加密的密钥。流程如下：</p><ol><li>服务器发送公钥</li><li>客户端生成对称加密的密钥，用服务度公钥加密传送给服务端</li><li>服务端利用私钥进行解密</li><li>后续用客户端的对称加密的密钥与客户端通信</li></ol><p>虽然保证机密性，但却还不够安全，比如中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，你拿到了假的公钥，你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。</p><p>那么如何证明浏览器收到的公钥一定是该网站的公钥？</p><h3 id="数字证书和-ca-机构组成的证书信任链" tabindex="-1"><a class="header-anchor" href="#数字证书和-ca-机构组成的证书信任链" aria-hidden="true">#</a> 数字证书和 CA 机构组成的证书信任链</h3><p>第三方信任机构，对网站颁发的“身份证”，也就是数字证书。数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器根据证书匹配下信息并从里获取公钥就行了。</p><p>但证书本身的传输也是明文的，如何防止被篡改以及证书信任问题？</p><ol><li>数字证书的数字签名及验证</li><li>证书信任链</li></ol><h4 id="数字签名及验证" tabindex="-1"><a class="header-anchor" href="#数字签名及验证" aria-hidden="true">#</a> 数字签名及验证</h4><p>数字签名，就是数字证书的“防伪技术”。其实原理就是用私钥对证书签名，<strong>因为只有私钥加密的东西公钥才能解密，也就能对应认证对方身份</strong>。</p><p><img src="images/a5a0dc09e32b91676e6d0105be4a8978279c3edc32bc26cff18f43aada58647a.png" alt="图 13"></p><p>数字签名的制作过程：</p><ol><li>CA机构拥有非对称加密的私钥和公钥。</li><li>CA机构对证书明文数据进行摘要算法（也就是 hash 算法）。</li><li>对 hash 值用私钥加密，得到数字签名（摘要算法虽然保证了证书内容的完整性，但是摘要也是明文传输，中间人也可能一起篡改）</li></ol><blockquote><p>有了加密，为什么制作数字签名时需要hash一次？<br> 非对称加密效率较差，hash后得到的是固定长度的信息，对 hash 加解密就快很多。</p></blockquote><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，签名S。</li><li>用 CA 机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到 hash 值</li><li>用证书里指明的摘要算法对证书明文进行 hash</li><li>对比两者 hash 值，相等则表明证书可信</li></ol><p><img src="/assets/img/1660873486128.dfbc9b5d.png" alt="图 2"></p><h4 id="证书信任链" tabindex="-1"><a class="header-anchor" href="#证书信任链" aria-hidden="true">#</a> 证书信任链</h4><p>除了要解决服务器的信任，还要解决签发机构的信任，再引入一个第三方机构？然后又染后？如此套娃，恐怕不行。</p><p>将颁发证书的机构划分为两种类型，根 CA(Root CAs)和中间 CA(Intermediates CAs)，通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA。</p><p>因此，每个根 CA 机构都维护了一个树状结构，一个根 CA 下面包含多个中间 CA，而中间 CA 又可以包含多个中间 CA。这样就形成了一个证书链，你可以沿着证书链从用户证书追溯到根证书。</p><p><img src="/assets/img/1660877165877.08dfa6e4.png" alt="图 3"></p><p><strong>根证书的 CA 机构作为最后的信任源！</strong></p><p>首先操作系统和浏览器都内置了各大 CA 的根证书。浏览器会对服务器返回的是证书链（不包括根证书，根证书预置在浏览器中）查找到根证书，然后逐级使用上一级证书的公钥对下一级证书进行摘要验签。</p><p><img src="/assets/img/1648394387393.f5fb5ac9.png" alt="图 6"></p><p><img src="/assets/img/1648394415188.d0deaada.png" alt="图 7"></p><p>浏览器怎么证明根证书是合法的？其实浏览器的判断策略很简单，它只是简单地判断这个根证书在不在操作系统里面，如果在，那么浏览器就认为这个根证书是合法的，如果不在，那么就是非法的。</p><p>从上流程分析可知，如果证书链的最后一端如果遭到恶意攻击，那么 https 并非是绝对安全的。</p><h3 id="https-安全原理总结" tabindex="-1"><a class="header-anchor" href="#https-安全原理总结" aria-hidden="true">#</a> https 安全原理总结</h3><p>SSL/TLS 为 http 增加了安全特性具体体现：</p><ul><li>数据传输安全 <ul><li>保密性：靠混合加密解决，非对称加密实现对称加密秘钥传递，对称加密实现内容加密</li><li>完整性：靠摘要算法解决</li></ul></li><li>通过数字证书和 CA 机构组成的证书链，确保浏览器对服务器的信任问题 <ul><li>数字签名是用私钥对证书的摘要进行加密，可以由公钥解密后进行摘要验证，实现身份认证和不可否认</li></ul></li></ul><h2 id="tls-连接" tabindex="-1"><a class="header-anchor" href="#tls-连接" aria-hidden="true">#</a> TLS 连接</h2><h3 id="rsa-握手" tabindex="-1"><a class="header-anchor" href="#rsa-握手" aria-hidden="true">#</a> RSA 握手</h3><p><img src="/assets/img/1650960138695.be503c44.png" alt="图 19"></p><ol><li>客户端发一个“Client Hello”消息，里面有本地 TLS 版本号、支持的密码套件列表，还有一个客户端随机数（Client Random）</li><li>服务器收到消息后，会确认 TLS 版本，从密码套件列表选择一个密码套件，并生成一个服务端随机数（Server Random），然后返回一个“Server Hello”消息告诉客户端，随后并将自己的证书发送给客户端，然后结束</li><li>客户端会进行证书验证，验证通过后，生成 pre-master 随机数，然后用公钥加密传给服务器</li><li>服务端使用自己的私钥进行解密，使用 pre-master 随机数、客户端随机数（Client Random）、服务端随机数（Server Random）算出 master secret 会话密钥，客户端也是同样做法</li><li>客户端告诉服务器我之后都使用加密进行通信了，结束；服务端也告诉客户端，我也要开始使用加密通信了，over</li><li>之后双方使用 master secret进行消息加密</li></ol><h3 id="ecdhe-握手过程" tabindex="-1"><a class="header-anchor" href="#ecdhe-握手过程" aria-hidden="true">#</a> ECDHE 握手过程</h3><p><img src="/assets/img/1650959174145.8aad4e74.png" alt="图 18"></p><p><img src="/assets/img/1650900031714.020e3329.png" alt="图 17"></p><ol><li>客户端发一个“Client Hello”消息，里面有本地 TLS 版本号、支持的密码套件列表，还有一个客户端随机数（Client Random）</li><li>服务器收到消息后，会确认 TLS 版本，从密码套件列表选择一个密码套件，并生成一个服务端随机数（Server Random），然后发送一个“Server Hello”消息告诉客户端，并将自己的证书发送给客户端</li><li>服务器发送 “Server Key Exchange” 消息，里面主要是 ECDHE 算法的服务端参数（Server Params），然后发送结束</li><li>客户端证书验证通过后，则发送 “Client Key Exchange” 消息，里面是 ECDHE 算法的客户端参数（Client Params）</li><li>客户端和服务器可以根据 Client Params、Server Params 用 ECDHE 算法计算出 Pre-Master 随机数，然后使用 Client Random、Server Random 和 Pre-Master 生成会话密钥的主密 Master Secret</li></ol><h2 id="tls-1-3" tabindex="-1"><a class="header-anchor" href="#tls-1-3" aria-hidden="true">#</a> TLS/1.3</h2><p>TLS/1.3 新增内容：</p><ul><li>扩展协议</li><li>强化安全、简化密码套件</li><li>提升性能：1-RTT 握手</li></ul><h3 id="扩展协议" tabindex="-1"><a class="header-anchor" href="#扩展协议" aria-hidden="true">#</a> 扩展协议</h3><p>由于 1.1、1.2 等协议已经出现了很多年，很多应用软件、中间代理（官方称为“MiddleBox”）只认老的记录协议格式，更新改造很困难，甚至有些只认记录头的 Version 字段仅为 1.2。为了保证兼容旧版本而扩展支持 1.3，新增了扩展协议：</p><div class="language-text ext-text"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292f;">Handshake Protocol: Client Hello</span></span>
<span class="line"><span style="color:#24292f;">    Version: TLS 1.2 (0x0303)</span></span>
<span class="line"><span style="color:#24292f;">    Extension: supported_versions (len=11)</span></span>
<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.3 (0x0304)</span></span>
<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.2 (0x0303)</span></span>
<span class="line"><span style="color:#24292f;"></span></span></code></pre></div><p>只要是 TLS1.3 协议，握手的“Hello”消息后面就必须有“supported_versions”扩展，它除了标记了 TLS 的版本号，还支持等其他 1.3 许多重要的功能。使用它就能区分新旧协议，旧服务器不支持 supported_versions 就会忽略，这样自动“后向兼容”降级成了 1.2。</p><h3 id="强化安全、简化密码套件" tabindex="-1"><a class="header-anchor" href="#强化安全、简化密码套件" aria-hidden="true">#</a> 强化安全、简化密码套件</h3><p>TLS1.3 废除了很多有漏洞、加密弱的加密算法，这样简化了密码套件列表：</p><p><img src="/assets/img/1650987278663.cc0a746e.png" alt="图 20"></p><p>其中最主要废除 RSA 和 DH 密钥交换算法，只保留了 ECDHE 和 DHE。RSA 和 DH 主要不具备“向前安全”性：服务器私钥参与密钥交换算法过程，一旦私钥泄露或被破解，那么黑客就能够使用私钥解密出之前所有报文的“Pre-Master”，再算出会话密钥，破解所有密文；而 ECDHE、DHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的。</p><h3 id="提升性能-1-rtt-握手" tabindex="-1"><a class="header-anchor" href="#提升性能-1-rtt-握手" aria-hidden="true">#</a> 提升性能：1-RTT 握手</h3><p>TLS1.2 握手过程需要 2-RTT 才能完成握手，TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。</p><p><img src="/assets/img/1650988382793.35e86c87.png" alt="图 21"></p><p>客户端在“Client Hello”消息里直接用“supported_groups”带上支持的曲线，比如 P-256、x25519，用“key_share”带上曲线对应的客户端公钥参数，用“signature_algorithms”带上签名算法。</p><div class="language-text ext-text"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292f;">Handshake Protocol: Client Hello</span></span>
<span class="line"><span style="color:#24292f;">    Version: TLS 1.2 (0x0303)</span></span>
<span class="line"><span style="color:#24292f;">    Random: cebeb6c05403654d66c2329…</span></span>
<span class="line"><span style="color:#24292f;">    Cipher Suites (18 suites)</span></span>
<span class="line"><span style="color:#24292f;">        Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)</span></span>
<span class="line"><span style="color:#24292f;">        Cipher Suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)</span></span>
<span class="line"><span style="color:#24292f;">        Cipher Suite: TLS_AES_256_GCM_SHA384 (0x1302)</span></span>
<span class="line"><span style="color:#24292f;">    Extension: supported_versions (len=9)</span></span>
<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.3 (0x0304)</span></span>
<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.2 (0x0303)</span></span>
<span class="line"><span style="color:#24292f;">    Extension: supported_groups (len=14)</span></span>
<span class="line"><span style="color:#24292f;">        Supported Groups (6 groups)</span></span>
<span class="line"><span style="color:#24292f;">            Supported Group: x25519 (0x001d)</span></span>
<span class="line"><span style="color:#24292f;">            Supported Group: secp256r1 (0x0017)</span></span>
<span class="line"><span style="color:#24292f;">    Extension: key_share (len=107)</span></span>
<span class="line"><span style="color:#24292f;">        Key Share extension</span></span>
<span class="line"><span style="color:#24292f;">            Client Key Share Length: 105</span></span>
<span class="line"><span style="color:#24292f;">            Key Share Entry: Group: x25519</span></span>
<span class="line"><span style="color:#24292f;">            Key Share Entry: Group: secp256r1</span></span>
<span class="line"><span style="color:#24292f;"></span></span></code></pre></div><p>服务端还是要给出一个随机数（Server Random）和选定密码套件，最主要在“supported_versions”里确认使用的是 TLS1.3，然后在“key_share”扩展带上曲线和对应的公钥参数。</p><div class="language-text ext-text"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292f;">Handshake Protocol: Server Hello</span></span>
<span class="line"><span style="color:#24292f;">    Version: TLS 1.2 (0x0303)</span></span>
<span class="line"><span style="color:#24292f;">    Random: 12d2bce6568b063d3dee2…</span></span>
<span class="line"><span style="color:#24292f;">    Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)</span></span>
<span class="line"><span style="color:#24292f;">    Extension: supported_versions (len=2)</span></span>
<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.3 (0x0304)</span></span>
<span class="line"><span style="color:#24292f;">    Extension: key_share (len=36)</span></span>
<span class="line"><span style="color:#24292f;">        Key Share extension</span></span>
<span class="line"><span style="color:#24292f;">            Key Share Entry: Group: x25519, Key Exchange length: 32</span></span>
<span class="line"><span style="color:#24292f;"></span></span></code></pre></div><h2 id="学习参考" tabindex="-1"><a class="header-anchor" href="#学习参考" aria-hidden="true">#</a> 学习参考</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener noreferrer">彻底搞懂HTTPS的加密原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>《透视 HTTP 协议》</p></li><li><p>《浏览器工作原理与实践》</p></li><li><p><a href="https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity" target="_blank" rel="noopener noreferrer">SSL Certificate framework 101: How does the browser actually verify the validity of a given server certificate?<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li><li><p>原理</p><ul><li>混合加密：使用非对称加密传输对称加密密钥</li><li>数字证书（包含公钥）</li><li>数字签名及验证：私钥加密，证书公钥解密；</li></ul></li></ul><p>ECDHE中，没有采用服务器公钥来加密数据，而是采用交换两端的椭圆曲线公钥来保证pre_master的安全性 RSA中pre_master由客户端生成，采用服务器公钥加密pre_master来保证pre_master的安全性</p><p>然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。 对称加密的私钥又是会话级的随机数=一次会话一个私钥。就算别人baoli破解也只是破解了一个会话（TCP 长连接期间）。</p><p>对称加密：AES_128/256 非：RSA，rsa一般要2048位</p><ul><li>现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”，“PRF”就是伪随机数函数，它基于密码套件里的最后一个参数，比如这次的 SHA384，通过摘要算法来再一次强化“Master Secret”的随机性。</li><li>客户端发一个“Change Cipher Spec”</li><li>然后再发一个“Finished”消息</li><li>服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</li></ul><p>主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患</p><p>ECDHE 算法</p></div><!----></article></div><footer class="footer footer-center p-4 bg-base-300 text-base-content opacity-60"><div><p>©2017-2021 laoergege.cn. All right reserved. </p><p><a href="https://beian.miit.gov.cn" target="_blank" class="link link-hover">粤ICP备2022020679号</a></p></div></footer><!--]--><!----><!--]--></div>
    <script src="/assets/js/runtime~app.7d4bd660.js" defer></script><script src="/assets/js/5838.13a569e5.js" defer></script><script src="/assets/js/app.7e792774.js" defer></script>
</body>

</html>