"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[9157],{3186:(l,e,i)=>{i.r(e),i.d(e,{data:()=>t});const t={key:"v-88c7f226",path:"/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AWebAPI/Web%20%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5.html",title:"Web 前端性能优化策略",lang:"zh-CN",frontmatter:{release:!0,tags:["性能优化","web"]},excerpt:"",headers:[{level:2,title:"资源优先级",slug:"资源优先级",children:[]},{level:2,title:"关键资源",slug:"关键资源",children:[]},{level:2,title:"代码拆分分析",slug:"代码拆分分析",children:[]},{level:2,title:"渲染阻塞资源",slug:"渲染阻塞资源",children:[]},{level:2,title:"资源优先级",slug:"资源优先级-1",children:[]},{level:2,title:"重排、重绘",slug:"重排、重绘",children:[]},{level:2,title:"强制同步布局和布局抖动",slug:"强制同步布局和布局抖动",children:[]}],git:{createdTime:1661172477e3,updatedTime:1661172477e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:1}]}}},8268:(l,e,i)=>{i.r(e),i.d(e,{default:()=>Bl});var t=i(5393);const a=i.p+"assets/img/timestamp-diagram.9566062f.svg",r=i.p+"assets/img/main-thread.a7cd1bed.svg",n=i.p+"assets/img/1652027860442.8bb9a55c.png",u=i.p+"assets/img/1652171797590.1dfa8b76.png",d=i.p+"assets/img/1652173705622.d58ab616.png",s=i.p+"assets/img/1652177417311.2dce4478.png",o=i.p+"assets/img/1652177631907.b0d2c335.png",p=i.p+"assets/img/1652177877467.3cd243cf.png",c=i.p+"assets/img/1652179222963.f4bc39fb.png",h=i.p+"assets/img/4b690f39c941560efb2f990d09c90d3dda3f0a161c7d2451f47827864f8b1432.e33c5536.svg",g=i.p+"assets/img/critical_render_path_CSS_JS_karamalegos_2.5e4e32c9.svg",_=i.p+"assets/img/1655746490005.366f888e.png",S=i.p+"assets/img/ba56488b8103323be27ea75cf8a1b8c2545aaac8e6e9bdd3dcd72d46357f1dde.f6f657bb.png",f=i.p+"assets/img/da73a240becf5bd248a113b69137c7d1fe234f8af405840808d38dcaae8395a7.821c2912.png",b=i.p+"assets/img/c08d5d2e7675be10b62946d898236eb7dbf966fcedb04f99dcd1ab9f76d4f5b6.46f08622.png",E=(0,t._)("h1",{id:"web-前端性能优化策略",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#web-前端性能优化策略","aria-hidden":"true"},"#"),(0,t.Uk)(" Web 前端性能优化策略")],-1),m=(0,t.Uk)("性能指标了解"),k=(0,t.Uk)("页面加载 "),C=(0,t._)("li",null,[(0,t.Uk)("指标 "),(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Uk)("白屏（FP、FCP）：浏览器发起页面请求后到提交数据阶段，这时页面展示出来的还是之前页面的内容。当渲染进程“确认提交”之后会创建一个空白页面，我们通常把这段时间称为"),(0,t._)("strong",null,"解析白屏"),(0,t.Uk)("（这也就是 Web 应用与原生应用体验最大的区别之一，这对用户体验影响很大）。")]),(0,t._)("li",null,"首屏"),(0,t._)("li",null,"首屏可交互时间（FID、TBT、TTI）")])],-1),T=(0,t.Uk)("优化策略 "),U=(0,t.Uk)("资源网络请求（可打开 Chrome Devtools 工具的网络面板做性能分析） "),B=(0,t.uE)('<li>Queuing：请求排队，因为<a href="#%E8%B5%84%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7">资源优先级</a>以及 TCP 连接数量限制（HTTP/1.1 浏览器为每个域名最多维护 6 个连接导致的） <ul><li>并发请求 <ul><li>域名分片</li><li>HTTP/2（多路复用）</li></ul></li><li>请求合并（资源合并） <ul><li>图标：雪碧图</li><li>代码打包</li></ul></li></ul></li>',1),A=(0,t.Uk)("TTFB：第一字节时间 "),M=(0,t._)("img",{src:a,alt:""},null,-1),v=(0,t.Uk)("HTTP 缓存"),D={href:"https://web.dev/preconnect-and-dns-prefetch/",target:"_blank",rel:"noopener noreferrer"},H=(0,t.Uk)("preconnect（预连接）、dns-prefetch（DNS 预查询）"),w=(0,t._)("li",null,"HTTP/1 keep-alive",-1),L=(0,t._)("li",null,[(0,t.Uk)("减少请求数据大小 "),(0,t._)("ul",null,[(0,t._)("li",null,"HTTP/2（头部压缩）")])],-1),O=(0,t._)("li",null,"提高服务器性能",-1),P=(0,t._)("li",null,[(0,t.Uk)("Content Download：资源下载时间 "),(0,t._)("ul",null,[(0,t._)("li",null,"减少资源大小：压缩/缩小"),(0,t._)("li",null,"提高宽带吞吐"),(0,t._)("li",null,"CDN")])],-1),J=(0,t.Uk)("关键渲染路径 "),F=(0,t.Uk)("消除"),W=(0,t._)("a",{href:"#%E6%B8%B2%E6%9F%93%E9%98%BB%E5%A1%9E%E8%B5%84%E6%BA%90"},"渲染阻塞资源",-1),y=(0,t._)("li",null,[(0,t.Uk)("JS "),(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Uk)("defer "),(0,t._)("ul",null,[(0,t._)("li",null,"异步加载"),(0,t._)("li",null,"等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行"),(0,t._)("li",null,"具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样")])]),(0,t._)("li",null,[(0,t.Uk)("async "),(0,t._)("ul",null,[(0,t._)("li",null,"异步加载"),(0,t._)("li",null,"加载就绪时运行")])])])],-1),x=(0,t.Uk)("CSS "),R=(0,t.Uk)("media: "),q={href:"https://github.com/filamentgroup/loadCSS",target:"_blank",rel:"noopener noreferrer"},I=(0,t.Uk)("loadCSS"),N=(0,t.uE)("<li>减少关键资源大小：以减少下载时间（往返次数 RTT） <ul><li>数据压缩 <ul><li>Gzip</li><li>Brotli</li></ul></li><li>代码缩小 <ul><li>删除空格、注释、混淆</li><li>消除未使用代码 <ul><li>TreeShaking</li><li>代码按需引入：第三方库依赖过大，会给首屏加载带来很大的压力，一般解决方式是按需求引入对应文件。</li></ul></li><li>发布传输现代化代码</li></ul></li></ul></li>",1),z=(0,t.Uk)("减少"),Z=(0,t._)("a",{href:"#%E5%85%B3%E9%94%AE%E8%B5%84%E6%BA%90"},"关键资源",-1),j=(0,t.Uk)("数量 "),X=(0,t.Uk)("延迟加载非关键资源 "),G=(0,t.Uk)("代码（非关键内容）拆分 + 懒加载 "),K=(0,t._)("li",null,[(0,t._)("a",{href:"#%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%88%86%E6%9E%90"},"代码拆分分析")],-1),Q={href:"https://web.dev/defer-non-critical-css/",target:"_blank",rel:"noopener noreferrer"},Y=(0,t.Uk)("延迟加载非关键 CSS"),V=(0,t._)("li",null,"图片懒加载",-1),$=(0,t.Uk)("最小化关键请求链路：提高关键请求优先级，缩短关键路径长度 "),ll=(0,t._)("li",null,"页面结构设计：将 CSS 放在文件头部，JavaScript 文件放在底部",-1),el=(0,t.Uk)("资源内联：通过 HTML 内联 JavaScript、CSS 来移除文件下载时间 "),il=(0,t._)("li",null,"内联内容不易过大，否则拆分成单文件，利用缓存",-1),tl=(0,t.Uk)("内容大小参考 "),al={href:"https://hpbn.co/building-blocks-of-tcp/#slow-start-restart",target:"_blank",rel:"noopener noreferrer"},rl=(0,t.Uk)("TCP 慢启动"),nl=(0,t.Uk)("，首屏内容保持在 14 KB （压缩）以下，即 1-RTT 最佳 🤔"),ul=(0,t._)("li",null,[(0,t.Uk)("Resource Priority Hints "),(0,t._)("ul",null,[(0,t._)("li",null,"preload"),(0,t._)("li",null,"prefetch"),(0,t._)("li",null,"fetchpriority")])],-1),dl=(0,t._)("li",null,[(0,t.Uk)("渲染模式 "),(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Uk)("CSR "),(0,t._)("ul",null,[(0,t._)("li",null,"SSR"),(0,t._)("li",null,"prerender（预渲染）")])])])],-1),sl=(0,t.uE)('<li>交互渲染 <ul><li>指标 <ul><li>帧率</li><li>交互响应速度</li></ul></li><li>绘制一帧生命周期 <img src="'+r+'" alt=""></li><li>生成一帧的方式： <ul><li><a href="#%E9%87%8D%E6%8E%92%E9%87%8D%E7%BB%98">重排(reflow)、重绘(repaint)</a></li><li>合成线程直接进行页面合成</li></ul></li><li>优化原则：避免抢占主线程过多时间，让渲染引擎稳定生成更多帧，提高帧率 <ul><li>JS <ul><li>对输入处理程序防抖</li><li>减少 JavaScript 脚本执行时间 <ul><li>时间分片</li><li>WebWork 多线程</li></ul></li><li>防止内存泄漏，系统频繁的垃圾回收</li></ul></li><li>渲染 <ul><li>避免<a href="#%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80%E5%92%8C%E5%B8%83%E5%B1%80%E6%8A%96%E5%8A%A8">强制同步布局和布局抖动</a><ul><li>读写分离：尽量不要在修改 DOM 结构时再去执行 DOM 查询操作</li><li>批量处理 + 异步更新 <ul><li>使用 DOMFragment 缓存批量化 DOM 操作</li><li>隐藏元素，进行批修改再显示</li><li>拷贝元素，进行批修改再替换</li></ul></li></ul></li><li>尽可能减少 reflow、repaint 的工作</li><li>合理利用分层合成机制：合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的 <ul><li>利用 CSS3 实现动画</li><li>将元素提升单独图层：减少重排重绘范围 <ul><li>will-change，能够将要执行动画的某个元素提前单独生成一个图层</li><li>translateZ</li><li>opacity</li><li>filters</li></ul></li></ul></li></ul></li></ul></li></ul></li>',1),ol=(0,t._)("h2",{id:"资源优先级",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#资源优先级","aria-hidden":"true"},"#"),(0,t.Uk)(" 资源优先级")],-1),pl=(0,t._)("p",null,"在优先请求队列中，浏览器对不同资源类型请求有相应的优先级，高优先级的先进行请求。",-1),cl=(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t.Uk)("可通过 Chrome NetWork 面板查看 Priority 列。 "),(0,t._)("img",{src:n,alt:"图 4"})])],-1),hl={href:"https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc/edit",target:"_blank",rel:"noopener noreferrer"},gl=(0,t.Uk)("Chrome 资源优先级文档"),_l=(0,t.uE)('<table><thead><tr><th>资源类型</th><th>优先级</th></tr></thead><tbody><tr><td>HTML</td><td>Highest</td></tr><tr><td>Font</td><td>Highest</td></tr><tr><td>Font (preload)</td><td>High</td></tr><tr><td>CSS</td><td>Highest</td></tr><tr><td>CSS</td><td>Highest</td></tr><tr><td>Images</td><td>默认是 Low，在初始视口中渲染时升级为 High</td></tr><tr><td>JS</td><td>Highest</td></tr><tr><td>Ajax, XHR, or fetch() API</td><td>High</td></tr></tbody></table><h2 id="关键资源" tabindex="-1"><a class="header-anchor" href="#关键资源" aria-hidden="true">#</a> 关键资源</h2><p>关键资源是指对页面初始视口的首屏渲染所需要的资源。</p><p>如何确定关键资源？从界面上感性角度去理解</p><p><img src="'+u+'" alt="图 5"></p><p>或者通过 DevTools Performance 面板观察 FP、FCP、LCP 或者自定义首屏指标之前发起的请求链去进行确认，在指标之前的请求大致可认为是关键资源：</p><p><img src="'+d+'" alt="图 7"></p><p>Lighthouse 性能审计：以高优先级的资源为关键资源</p><p><img src="images/1652174915698.png" alt="图 8"></p><h2 id="代码拆分分析" tabindex="-1"><a class="header-anchor" href="#代码拆分分析" aria-hidden="true">#</a> 代码拆分分析</h2><p>可通过DevTools 中的 Coverage 面板查看资源利用率，一般可挑选体积大和利用率低的文件进行拆分</p><p><img src="'+s+'" alt="图 9"></p><p>或者 Lighthouse 性能审计板块</p><p><img src="'+o+'" alt="图 10"></p>',14),Sl=(0,t.Uk)("文件依赖分析，可通过相应的构建工具如 webpack 的"),fl={href:"https://github.com/webpack-contrib/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer"},bl=(0,t.Uk)("Webpack Bundle Analyzer"),El=(0,t._)("p",null,[(0,t._)("img",{src:p,alt:"图 11"})],-1),ml=(0,t._)("p",null,"Lighthouse Treemap 工具（需要开启 sourcemap）",-1),kl={href:"https://sia.codes/posts/lighthouse-treemap/",target:"_blank",rel:"noopener noreferrer"},Cl=(0,t.Uk)("Explore JavaScript Dependencies With Lighthouse Treemap"),Tl=(0,t.uE)('<p><img src="'+c+'" alt="图 12"></p><p>最后代码中删除未使用的库或文件！</p><h2 id="渲染阻塞资源" tabindex="-1"><a class="header-anchor" href="#渲染阻塞资源" aria-hidden="true">#</a> 渲染阻塞资源</h2><p>HTML、JS、CSS 资源加载行为会导致浏览器关键渲染路径（Critical Rendering Path）阻塞，了解浏览器对 HTML、JS、CSS 的加载行为：</p><ul><li>HTML <ul><li>流式解析：HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据</li><li>预加载扫描：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件</li><li>流式渲染：现代浏览器增量构建 DOM，只要有可用的 DOM 就无需等待 HTML 完全解析再渲染，除非 CSS 渲染阻塞</li></ul></li><li>JS：无论内联还是外链，都会阻塞 DOM 解析，直到 JS 加载执行完成</li><li>CSS：CSS 解析不是增量过程，如果浏览器在解析样式表内容时开始逐步构建 CSSOM，它将导致渲染树的多次渲染，造成样式闪烁（FOUC）因为 css 的可重叠样式规则 <ul><li>内联：会阻塞 DOM 解析，直到内联 CSS 解析完成</li><li>外链 <ul><li>link in head <ul><li>一般不会阻塞 DOM 解析 <img src="'+h+'" alt=""></li><li>但如果后面跟 JS 脚本的情况，会阻塞后面 JS 脚本执行，相当于间接导致阻塞 DOM 解析 <img src="'+g+'" alt=""> JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。</li><li>阻塞渲染 <ul><li>浏览器在渲染页面的过程需要解析 HTML、CSS 以得到 DOM 树和 CSS 规则树，它们结合后才生成最终的渲染树并渲染，一旦浏览器发出获取外部样式表的请求，渲染树的构建就会停止，因此，关键渲染路径( CRP ) 也被卡住，屏幕上没有渲染任何内容</li><li>浏览器可以使用 CSSOM 树的旧状态来生成渲染树，因为 HTML 正在被解析以在屏幕上逐步渲染事物。但这有一个巨大的缺点。在这种情况下，一旦样式表被下载和解析，并且 CSSOM 被更新，渲染树将被更新并呈现在屏幕上。现在，使用旧 CSSOM 生成的渲染树节点将使用新样式重新绘制，并且还可能导致无样式内容( FOUC )闪烁，这对 UX 非常不利。因此浏览器将等到样式表被加载和解析 w 完成，CRP 才会被解锁。正因为如此，建议尽可能早地加载所有外部样式表，可能在 head 部分中。</li></ul></li></ul></li><li>link in body：这是一种缺失规范，浏览器之间怪异的行为 <ul><li>Safari：阻止渲染，直到所有 CSS 加载执行完毕</li><li>Firefox：不会阻塞渲染，可能导致样式闪烁</li><li>Chrome/Edge：阻塞 DOM 解析，但可渲染之前的内容</li></ul></li></ul></li></ul></li></ul><p>总的来说，HTML 可流式渲染，主要是 JS 阻塞解析，而 CSS 阻塞渲染，也可能间接阻塞 HTML 解析。</p><p>但也并不是所有的 JS、CSS 会造成渲染阻塞，比如：</p><p><code>&lt;script&gt;</code> tags in the <code>&lt;head&gt;</code> which do not have at least one of the following attributes: <strong>async, defer, module</strong> Stylesheet <code>&lt;link&gt;</code> tags in the <code>&lt;head&gt;</code> without a <strong>disabled</strong> attribute or a <strong>media query</strong> which does not match (e.g., print)</p><h2 id="资源优先级-1" tabindex="-1"><a class="header-anchor" href="#资源优先级-1" aria-hidden="true">#</a> 资源优先级</h2><h2 id="重排、重绘" tabindex="-1"><a class="header-anchor" href="#重排、重绘" aria-hidden="true">#</a> 重排、重绘</h2><p><img src="'+_+'" alt="图 2"></p><ol><li>重排、重绘分别对应浏览器渲染流程中 Layout、Paint 阶段，Layout 位于Paint 前，重排一定会导致重绘，重绘不一定会导致重排</li><li>浏览器会自动合并更改，在达到某个数量或时间后，会合并为一次 reflow，而 reflow 是渲染页面的重要一步，打开浏览器就一定会至少 reflow 一次，所以我们不可能避免 reflow</li></ol><blockquote><p>触发重排重绘的属性列表：https://csstriggers.com/</p></blockquote><h2 id="强制同步布局和布局抖动" tabindex="-1"><a class="header-anchor" href="#强制同步布局和布局抖动" aria-hidden="true">#</a> 强制同步布局和布局抖动</h2><p>正常情况下渲染任务中的样式计算、布局计算都是在另外的任务中异步完成的</p><p><img src="'+S+'" alt="图 3"></p><p>如果在修改 DOM 结构时候再去执行 DOM 查询操作，就会发生强制同步布局。</p><p>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。</p><p><img src="'+f+'" alt="图 2"></p><p>布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</p><p><img src="'+b+'" alt="图 4"></p><p><strong>如此频繁会大大影响当前函数的执行效率，从而阻塞其他渲染任务执行</strong>。</p>',22),Ul={},Bl=(0,i(3860).Z)(Ul,[["render",function(l,e){const i=(0,t.up)("RouterLink"),a=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)("div",null,[E,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t.Wm)(i,{to:"/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AWebAPI/Web%20%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"},{default:(0,t.w5)((()=>[m])),_:1})])]),(0,t._)("ul",null,[(0,t._)("li",null,[k,(0,t._)("ul",null,[C,(0,t._)("li",null,[T,(0,t._)("ul",null,[(0,t._)("li",null,[U,(0,t._)("ul",null,[B,(0,t._)("li",null,[A,M,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Wm)(i,{to:"/HTTP/http%20%E7%BC%93%E5%AD%98.html"},{default:(0,t.w5)((()=>[v])),_:1})]),(0,t._)("li",null,[(0,t._)("a",D,[H,(0,t.Wm)(a)])]),w,L,O])]),P])]),(0,t._)("li",null,[J,(0,t._)("ul",null,[(0,t._)("li",null,[F,W,(0,t._)("ul",null,[y,(0,t._)("li",null,[x,(0,t._)("ul",null,[(0,t._)("li",null,[R,(0,t._)("a",q,[I,(0,t.Wm)(a)])])])])])]),N,(0,t._)("li",null,[z,Z,j,(0,t._)("ul",null,[(0,t._)("li",null,[X,(0,t._)("ul",null,[(0,t._)("li",null,[G,(0,t._)("ul",null,[K,(0,t._)("li",null,[(0,t._)("a",Q,[Y,(0,t.Wm)(a)])])])]),V])])])]),(0,t._)("li",null,[$,(0,t._)("ul",null,[ll,(0,t._)("li",null,[el,(0,t._)("ul",null,[il,(0,t._)("li",null,[tl,(0,t._)("a",al,[rl,(0,t.Wm)(a)]),nl])])]),ul])])])]),dl])])])]),sl]),ol,pl,cl,(0,t._)("p",null,[(0,t._)("a",hl,[gl,(0,t.Wm)(a)])]),_l,(0,t._)("p",null,[Sl,(0,t._)("a",fl,[bl,(0,t.Wm)(a)])]),El,ml,(0,t._)("blockquote",null,[(0,t._)("p",null,[(0,t._)("a",kl,[Cl,(0,t.Wm)(a)])])]),Tl])}]])},3860:(l,e)=>{e.Z=(l,e)=>{const i=l.__vccOpts||l;for(const[l,t]of e)i[l]=t;return i}}}]);