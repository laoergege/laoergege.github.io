"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[9019],{1349:(l,i,e)=>{e.r(i),e.d(i,{data:()=>t});const t={key:"v-78263bfa",path:"/JavaScript/JavaScript%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F.html",title:"JavaScript 类型系统",lang:"zh-CN",frontmatter:{release:!0,tags:["javascript","类型系统"],desc:"JavaScript 类型系统知识体系"},excerpt:"",headers:[{level:2,title:"类型判断",slug:"类型判断",children:[]},{level:2,title:"弱类型：隐式类型转换",slug:"弱类型-隐式类型转换",children:[]}],git:{createdTime:1634218211e3,updatedTime:1648535436e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:17}]}}},6697:(l,i,e)=>{e.r(i),e.d(i,{default:()=>o});var t=e(5393);const u=e.p+"assets/img/1642863972248.63733c80.png",a=[(0,t.uE)('<h1 id="javascript-类型系统" tabindex="-1"><a class="header-anchor" href="#javascript-类型系统" aria-hidden="true">#</a> JavaScript 类型系统</h1><ul><li>JavaScript 类型系统 <ul><li>动态类型 <ul><li>运行阶段才能确定变量类型</li><li><a href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">类型判断</a></li></ul></li><li><a href="#%E5%BC%B1%E7%B1%BB%E5%9E%8B%EF%BC%9A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">弱类型：隐式类型转换</a></li><li>分类 <ul><li>原始类型 <ul><li>Undefined：表示未定义或未初始赋值 <ul><li>JavaScript 的代码 undefined 是一个变量，而并非是一个关键字</li><li>全局 undefined 是无法修改，但可以被作为局部变量篡改</li><li>为了避免无意中被篡改，建议使用 void 0 来获取 undefined 值</li></ul></li><li>Null：表示空值</li><li>Boolean</li><li>Number <ul><li>ECMAScript 中的 Number 类型使用 IEEE754 标准来表示数字（整数和浮点数）</li><li>采用双精确度 64位：1 符号位 + 11 指数位 + 52 尾数</li><li><code>0.1 + 0.2 !== 0.3</code>：怎么解决浮点数运算缺失 <ul><li>bigInt</li><li>第三方库：math.js</li><li>整型存储，再格式化显示</li><li>转换成字符串运算</li><li>使用 Number.EPSILON 误差范围：<code>Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON</code></li></ul></li></ul></li><li>String <ul><li>Unicode 字符集，UTF16 编码方式</li><li>JavaScript 中的字符串一旦构造出来就无法改变（原内存空间），变量重新赋值只是重新创建新的字符串</li></ul></li><li>Symbol <ul><li>创建唯一标识符，作为对象属性名，防止冲突</li><li>创建对象的“隐藏”属性</li></ul></li><li>BigInt</li></ul></li><li>引用类型 <ul><li>Object</li><li>内置特殊对象类型 <ul><li>Boolean</li><li>Number</li><li>String</li><li>Array</li><li>RegExp</li><li>Error</li><li>Date</li><li>Function <ul><li>按值传递 <blockquote><p>按值传递，即复制实参的值；引用传递，即复制实参的地址</p></blockquote></li></ul></li><li>数据结构 <ul><li>Set、WeakSet</li><li>Map、WeakMap</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="类型判断" tabindex="-1"><a class="header-anchor" href="#类型判断" aria-hidden="true">#</a> 类型判断</h2><ul><li>typeof <ul><li>无法判断除了 function 类型以外的其他具体引用类型</li><li><code>typeof null === &#39;object&#39;</code></li></ul></li><li>instanceof <ul><li>可以判断具体引用类型，但是不能正确判断基础数据类型</li><li>instanceof本质上是判断右边的构造函数的prototype对象是否存在于左边的原型链上。但根据原型链，<code>... instanceof Object</code> 都返回 true。</li></ul></li><li>Object.prototype.toString.call <ul><li>能够更加准确判断数据类型并统一返回格式为 “[object Xxx]” 的字符串，<code>Object.prototype.toString.call(null) // &#39;[object Null]&#39;</code></li></ul></li><li>数组 <ul><li>Array.isArray</li></ul></li></ul><h2 id="弱类型-隐式类型转换" tabindex="-1"><a class="header-anchor" href="#弱类型-隐式类型转换" aria-hidden="true">#</a> 弱类型：隐式类型转换</h2><ul><li>类型转换 <ul><li>显示转换，如 <code>String(&#39;123&#39;)</code></li><li>隐式转换，运算符会自动触发类型转换，如 <code>+&#39;123&#39;</code><ul><li>类型转换规则<br> 在 JS 中类型转换情况：toNumber 、 toString 、 toBoolean、toObject <img src="'+u+'" alt="图 11"><ul><li>StringToNumber <ul><li>Number</li><li>parseInt</li><li>parseFloat</li></ul></li><li>NumberToString <ul><li>String</li></ul></li><li>对象跟基本类型之间的转换 <ul><li>装箱转换 <ul><li>包装类</li></ul></li><li>拆箱转换 <ol><li>valueOf</li><li>toString</li><li>Symbol.toPrimitive(o [ , PreferredType ])</li></ol></li></ul></li></ul></li></ul></li></ul></li></ul><p>类型不同的变量比较时==运算只有三条规则：</p><ul><li>undefined 与 null 相等</li><li>字符串和 bool 都转为数字再比较</li><li>对象转换成 primitive 类型再比较 另一个是对象如果转换成了 primitive 类型跟等号另一边类型恰好相同，则不需要转换成数字。</li></ul>',8)],r={},o=(0,e(3860).Z)(r,[["render",function(l,i){return(0,t.wg)(),(0,t.iD)("div",null,a)}]])},3860:(l,i)=>{i.Z=(l,i)=>{const e=l.__vccOpts||l;for(const[l,t]of i)e[l]=t;return e}}}]);