"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[6458],{4152:(s,a,l)=>{l.r(a),l.d(a,{data:()=>n});const n={key:"v-4835f72d",path:"/JavaScript/JavaScript%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",title:"JavaScript 正则表达式",lang:"zh-CN",frontmatter:{release:!0,title:"JavaScript 正则表达式",tags:["javascript","regexp"],desc:"JavaScript 正则表达式"},excerpt:"",headers:[{level:2,title:"正则要么匹配字符，要么匹配位置",slug:"正则要么匹配字符-要么匹配位置",children:[{level:3,title:"字符类",slug:"字符类",children:[]},{level:3,title:"集合和范围",slug:"集合和范围",children:[]},{level:3,title:"量词",slug:"量词",children:[]},{level:3,title:"锚符 ^、$",slug:"锚符-、",children:[]},{level:3,title:"单词边界 \\b 和 \\B",slug:"单词边界-b-和-b",children:[]},{level:3,title:"前瞻断言和后瞻断言",slug:"前瞻断言和后瞻断言",children:[]}]},{level:2,title:"捕获组",slug:"捕获组-1",children:[{level:3,title:"括号+量词当作一整体进行匹配",slug:"括号-量词当作一整体进行匹配",children:[]},{level:3,title:"将匹配结果做为目标继续分组",slug:"将匹配结果做为目标继续分组",children:[]},{level:3,title:"分组命名 ?<name> 及引用：\\N 和 \\k<name>",slug:"分组命名-name-及引用-n-和-k-name",children:[]}]},{level:2,title:"正则表达式回溯法原理",slug:"正则表达式回溯法原理",children:[]},{level:2,title:"选择符 |",slug:"选择符",children:[]},{level:2,title:"练习题",slug:"练习题",children:[]},{level:2,title:"参考阅读",slug:"参考阅读",children:[]},{level:2,title:"JS 正则、字符串相关方法",slug:"js-正则、字符串相关方法",children:[]}],git:{createdTime:162046753e4,updatedTime:1645982303e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:5}]}}},7384:(s,a,l)=>{l.r(a),l.d(a,{default:()=>A});var n=l(5393);const o=l.p+"assets/img/greedy1.16a1f5c8.png",p=l.p+"assets/img/greedy2.fec39ab8.png",e=l.p+"assets/img/lazy-back-tracking.b2d64b2e.png",t=(0,n.uE)('<h1 id="javascript-正则表达式" tabindex="-1"><a class="header-anchor" href="#javascript-正则表达式" aria-hidden="true">#</a> JavaScript 正则表达式</h1><ul><li>JavaScript 正则表达式 <ul><li><a href="#%E6%AD%A3%E5%88%99%E8%A6%81%E4%B9%88%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E8%A6%81%E4%B9%88%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE">正则要么匹配字符，要么匹配位置</a><ul><li>字符 <ul><li>普通字符</li><li><a href="#%E5%AD%97%E7%AC%A6%E7%B1%BB">字符类</a><ul><li><a href="#unicode%E4%BF%AE%E9%A5%B0%E7%AC%A6-u-%E5%92%8C-class-p">Unicode：修饰符 “u” 和 class \\p{...}</a></li></ul></li><li><a href="#%E9%9B%86%E5%90%88%E5%92%8C%E8%8C%83%E5%9B%B4">集合和范围</a></li><li><a href="#%E9%87%8F%E8%AF%8D">量词</a><ul><li><a href="#%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D%E5%92%8C%E6%83%B0%E6%80%A7%E5%8C%B9%E9%85%8D">贪婪匹配和惰性匹配</a></li></ul></li></ul></li><li>位置 <ul><li><a href="#%E9%94%9A%E7%AC%A6-">锚符 ^、$</a><ul><li><a href="#%E5%A4%9A%E8%A1%8C%E6%A8%A1%E5%BC%8Fm">多行模式 m</a></li><li><a href="#%E9%94%9A%E7%AC%A6--%E5%AF%B9%E6%AF%94-n">锚符 ^$ 对比 \\n</a></li></ul></li><li><a href="#%E5%8D%95%E8%AF%8D%E8%BE%B9%E7%95%8C-b-%E5%92%8C-b">单词边界 \\b 和 \\B</a></li><li><a href="#%E5%89%8D%E7%9E%BB%E6%96%AD%E8%A8%80%E5%92%8C%E5%90%8E%E7%9E%BB%E6%96%AD%E8%A8%80">前瞻断言和后瞻断言</a><ul><li>前 x(?=y)、x(?!y)</li><li>后 (?&lt;=y)x、(?&lt;!y)x</li></ul></li></ul></li></ul></li><li>捕获组 <ul><li><a href="#%E6%8B%AC%E5%8F%B7%E9%87%8F%E8%AF%8D%E5%BD%93%E4%BD%9C%E4%B8%80%E6%95%B4%E4%BD%93%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D">括号+量词当作一整体进行匹配</a></li><li><a href="#%E5%B0%86%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C%E5%81%9A%E4%B8%BA%E7%9B%AE%E6%A0%87%E7%BB%A7%E7%BB%AD%E5%88%86%E7%BB%84">将匹配结果做为目标继续分组</a><ul><li><a href="">阻止分组</a></li></ul></li><li>分组命名 <code>?&lt;name&gt;</code> 及引用：<code>\\N</code> 和 <code>\\k&lt;name&gt;</code></li></ul></li><li>选择符 <code>|</code></li><li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%8E%9F%E7%90%86">正则表达式回溯法原理</a></li><li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98">练习题</a><ul><li><a href="#%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%A6%96%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%A4%A7%E5%86%99">将每个单词的首字母转换为大写</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-trim-%E6%96%B9%E6%B3%95%E6%A8%A1%E6%8B%9F">字符串 trim 方法模拟</a></li><li><a href="#%E5%8C%B9%E9%85%8D%E6%88%90%E5%AF%B9%E6%A0%87%E7%AD%BE">匹配成对标签</a></li><li><a href="#%E8%8E%B7%E5%8F%96-url-pathname">获取 URL pathname</a></li></ul></li><li>JS 正则、字符串相关方法 <ul><li>match</li><li>matchAll</li><li>replace</li><li>split</li><li>search</li></ul></li></ul></li></ul><p>正则表达式是搜索和替换字符串的一种强大方式。</p><p>正则表达式（可叫作“regexp”或者“reg”）包含<strong>模式</strong>和可选的<strong>修饰符</strong>。</p><p>创建 JavaScript 正则表达式的方式有：</p><ul><li>RegExp 实例 <code>regexp = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);</code></li><li>字面量 <code>regexp = /pattern/flag;</code></li></ul><blockquote><p>相比正则字面量的方式 <code>new RegExp</code> 允许从字符串中<strong>动态地构造模式</strong></p></blockquote><p>修饰符有</p><ul><li>i 不区分大小写</li><li>g 全局搜索所有匹配项</li><li>m 多行模式</li><li>u 开启完整的 unicode 支持</li><li>s 启用 “dotall” 模式，允许点 . 匹配换行符 \\n</li><li>y 粘滞模式</li></ul><h2 id="正则要么匹配字符-要么匹配位置" tabindex="-1"><a class="header-anchor" href="#正则要么匹配字符-要么匹配位置" aria-hidden="true">#</a> 正则要么匹配字符，要么匹配位置</h2><p>匹配字符的模式有</p><ul><li>普通字符</li><li>字符类</li><li>集合和范围</li></ul><p>无论是字符类还是集合、范围的模式都只能表示一个字符，<strong>量词</strong>用来形容我们所需要的数量</p><p>集合和范围模式赋予匹配单个字符能够有多种模式选择，但如果想匹配多个字符多种模式，可用选择符OR(|)</p><p><strong>匹配位置会消费位置字符，故对应位置的字符不会出现在结果中</strong>。匹配位置的模式有锚符：</p><h3 id="字符类" tabindex="-1"><a class="header-anchor" href="#字符类" aria-hidden="true">#</a> 字符类</h3><ul><li>\\d 数字0到9</li><li>\\D 非 \\d</li><li>\\s 空格、水平制表符\\t、垂直制表符\\v、换行符\\n、换页页符\\f、回车符\\r</li><li>\\S 非 \\s</li><li>\\w 拉丁字母、数字、下划线</li><li>\\W 非 \\w</li><li>. 任意字符，除 \\n</li><li>\\p{...} 配合修饰符u，表示 unicode 字符</li></ul><h4 id="unicode-修饰符-u-和-class-p" tabindex="-1"><a class="header-anchor" href="#unicode-修饰符-u-和-class-p" aria-hidden="true">#</a> Unicode：修饰符 “u” 和 class \\p{...}</h4><p>TODO 未完成，先占个坑位</p><h3 id="集合和范围" tabindex="-1"><a class="header-anchor" href="#集合和范围" aria-hidden="true">#</a> 集合和范围</h3><ul><li>集合，如 [eao] 意味着查找在 3 个字符 &#39;a&#39;、&#39;e&#39; 或者 `‘o’ 中的任意一个</li><li>范围，如 [0-5] 表示从 0 到 5 的数字，[\\d] 表示 0 到 9 数字；[0-9A-F]，搜索一个字符，满足数字 0 到 9 或字母 A 到 F</li><li>排除范围 [^…]，如 [^0-9] 匹配任何除了数字之外的字符</li><li>[...] 除了在方括号中有特殊含义的字符外，其它所有特殊字符都是都不需要添加反斜杠的，如 [-().^+] 会查找 -().^+ 的其中任意一个字符</li></ul><h3 id="量词" tabindex="-1"><a class="header-anchor" href="#量词" aria-hidden="true">#</a> 量词</h3><ul><li>+ 至少1次</li><li>* 至少0次</li><li>? 一个或零个</li><li>{n,m} 如 {5} 5次 {3,5} 3到5次 {3,} 大于等于3次</li></ul><h4 id="贪婪匹配和惰性匹配" tabindex="-1"><a class="header-anchor" href="#贪婪匹配和惰性匹配" aria-hidden="true">#</a> 贪婪匹配和惰性匹配</h4><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&#39;a &quot;witch&quot; and her &quot;broom&quot; is one&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/&quot;</span><span style="color:#0550AE;">.</span><span style="color:#CF222E;">+</span><span style="color:#0A3069;">&quot;/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;witch&quot; and her &quot;broom&quot;</span></span>\n<span class="line"><span style="color:#0A3069;">&#39;a &quot;witch&quot; and her &quot;broom&quot; is one&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/&quot;</span><span style="color:#0550AE;">.</span><span style="color:#CF222E;">+?</span><span style="color:#0A3069;">&quot;/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;witch&quot;、&quot;broom&quot;</span></span>\n<span class="line"></span></code></pre></div><p>量词有两种工作模式</p><p><strong>在贪婪模式下（默认情况下），量词都会尽可能地重复多次</strong>。</p><p>惰性模式(量词之后添加一个问号 &#39;?&#39;)只有在模式的剩余部分无法在给定位置匹配时，正则表达式引擎才会增加重复次数。</p>',28),c=(0,n.Uk)("参考 "),r={href:"https://zh.javascript.info/regexp-greedy-and-lazy",target:"_blank",rel:"noopener noreferrer"},i=(0,n.Uk)("贪婪量词和惰性量词"),y=(0,n.uE)('<h3 id="锚符-、" tabindex="-1"><a class="header-anchor" href="#锚符-、" aria-hidden="true">#</a> 锚符 ^、$</h3><p>符号 <code>^</code> 匹配文本开头，而美元符号 <code>$</code> 则匹配文本末尾</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> str1 </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;it&#39;s fleece was white as snow&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">(</span><span style="color:#0A3069;"> /snow</span><span style="color:#CF222E;">$</span><span style="color:#0A3069;">/</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">test</span><span style="color:#24292F;">(str1) ); </span><span style="color:#6E7781;">// true</span></span>\n<span class="line"></span></code></pre></div><h4 id="多行模式-m" tabindex="-1"><a class="header-anchor" href="#多行模式-m" aria-hidden="true">#</a> 多行模式 m</h4><p>修饰符 m 开启的多行模式下，^、$ 不仅仅匹配文本的开始与结束，还<strong>匹配每一行的开始与结束</strong></p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&#39;aaaab</span><span style="color:#0550AE;">\\n</span><span style="color:#0A3069;">ccccc&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/b</span><span style="color:#CF222E;">$</span><span style="color:#0A3069;">/</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// null</span></span>\n<span class="line"><span style="color:#0A3069;">&#39;aaaab</span><span style="color:#0550AE;">\\n</span><span style="color:#0A3069;">ccccc&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/b</span><span style="color:#CF222E;">$</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">mg</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// [&#39;b&#39;]</span></span>\n<span class="line"></span></code></pre></div><h4 id="锚符-对比-n" tabindex="-1"><a class="header-anchor" href="#锚符-对比-n" aria-hidden="true">#</a> 锚符 ^$ 对比 \\n</h4><p><code>\\n</code> 是匹配字符会出现在结果中，而 <code>$</code> 是匹配位置，会消费匹配到位置上的字符，故 <code>\\n</code> 不会出现在结果中。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&#39;aaaab</span><span style="color:#0550AE;">\\n</span><span style="color:#0A3069;">ccccc&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/b</span><span style="color:#0550AE;">\\n</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">mg</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// [&quot;b\\n&quot;]</span></span>\n<span class="line"><span style="color:#0A3069;">&#39;aaaab</span><span style="color:#0550AE;">\\n</span><span style="color:#0A3069;">ccccc&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/b</span><span style="color:#CF222E;">$</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">mg</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// [&quot;b&quot;]</span></span>\n<span class="line"></span></code></pre></div><h3 id="单词边界-b-和-b" tabindex="-1"><a class="header-anchor" href="#单词边界-b-和-b" aria-hidden="true">#</a> 单词边界 \\b 和 \\B</h3><p><code>\\b</code> 是单词边界，具体就是 <code>\\w</code> 与 <code>\\W</code> 之间的位置，也包括 <code>\\w</code> 与 <code>^</code> 之间的位置，和 <code>\\w</code> 与 <code>$</code> 之间的位置。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&quot;[JS] Lesson_01.mp4&quot;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">\\b</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">, </span><span style="color:#0A3069;">&#39;#&#39;</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span></span>\n<span class="line"></span></code></pre></div><p>\\B 就是 \\b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \\b，剩下的都是 \\B 的。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&quot;[JS] Lesson_01.mp4&quot;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">\\B</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">, </span><span style="color:#0A3069;">&#39;#&#39;</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot;</span></span>\n<span class="line"></span></code></pre></div><h3 id="前瞻断言和后瞻断言" tabindex="-1"><a class="header-anchor" href="#前瞻断言和后瞻断言" aria-hidden="true">#</a> 前瞻断言和后瞻断言</h3><p>前瞻断言</p><p>语法为：<code>x(?=y)</code>，它表示 “匹配 x, 仅在后面是 y 的情况&quot;” 语法为：<code>x(?!y)</code>，意思是 “查找 x, 但是仅在不被 y 跟随的情况下匹配成功”</p><p>后瞻断言</p><p>后瞻肯定断言：<code>(?&lt;=y)x</code>, 匹配 x, 仅在前面是 y 的情况。 后瞻否定断言：<code>(?&lt;!y)x</code>, 匹配 x, 仅在前面不是 y 的情况。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// 比如把 &quot;12345678&quot;，变成 &quot;12,345,678&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">// \\B 是词与词的边界，故相当 1#2#3#4#5#6#7#8，用 # 表示 \\B</span></span>\n<span class="line"><span style="color:#6E7781;">// 从后开始匹配 \\B，仅其后是三个数字</span></span>\n<span class="line"><span style="color:#0A3069;">&quot;12345678&quot;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">\\B</span><span style="color:#0A3069;">(?=(</span><span style="color:#0550AE;">\\d</span><span style="color:#CF222E;">{3}</span><span style="color:#0A3069;">)</span><span style="color:#CF222E;">$</span><span style="color:#0A3069;">)/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">, </span><span style="color:#0A3069;">&#39;,&#39;</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;12345,678&quot;</span></span>\n<span class="line"><span style="color:#6E7781;">// 要求 \\B 后面 3 个数字一组，也就是 \\d{3} 至少出现一次</span></span>\n<span class="line"><span style="color:#0A3069;">&quot;12345678&quot;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">\\B</span><span style="color:#0A3069;">(?=(</span><span style="color:#0550AE;">\\d</span><span style="color:#CF222E;">{3}</span><span style="color:#0A3069;">)</span><span style="color:#CF222E;">+$</span><span style="color:#0A3069;">)/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">, </span><span style="color:#0A3069;">&#39;,&#39;</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">//&quot;12,345,678&quot;</span></span>\n<span class="line"></span></code></pre></div><h4 id="捕获组" tabindex="-1"><a class="header-anchor" href="#捕获组" aria-hidden="true">#</a> 捕获组</h4><p>断言括号不会成为捕获分组，即内容不会再去匹配第一个匹配的结果，如果我们想要捕捉括号内的只需再加括号。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> str </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;1 turkey costs 30€&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> reg </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">/</span><span style="color:#0550AE;">\\d</span><span style="color:#CF222E;">+</span><span style="color:#0A3069;">(?=(€</span><span style="color:#CF222E;">|</span><span style="color:#0A3069;">kr))/</span><span style="color:#24292F;">; </span><span style="color:#6E7781;">// €|kr 两边有额外的括号</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( str.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(reg) ); </span><span style="color:#6E7781;">// 30, €</span></span>\n<span class="line"></span></code></pre></div><h2 id="捕获组-1" tabindex="-1"><a class="header-anchor" href="#捕获组-1" aria-hidden="true">#</a> 捕获组</h2><h3 id="括号-量词当作一整体进行匹配" tabindex="-1"><a class="header-anchor" href="#括号-量词当作一整体进行匹配" aria-hidden="true">#</a> 括号+量词当作一整体进行匹配</h3><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// 不带括号，模式 go+ 表示 g 字符，其后 o 重复一次或多次。例如 goooo 或 gooooooooo。</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">// 括号将字符组合，所以 (go)+ 匹配 go，gogo，gogogo等</span></span>\n<span class="line"><span style="color:#0A3069;">&#39;Gogogo now!&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/(go)</span><span style="color:#CF222E;">+</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">gi</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;Gogogo&quot;</span></span>\n<span class="line"></span></code></pre></div><h3 id="将匹配结果做为目标继续分组" tabindex="-1"><a class="header-anchor" href="#将匹配结果做为目标继续分组" aria-hidden="true">#</a> 将匹配结果做为目标继续分组</h3><blockquote><p>match 如果正则<strong>不带修饰符 g</strong>，正则引擎将用分组顺序匹配前一个匹配的结果</p></blockquote><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> str </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;I love JavaScript&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> result </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> str.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/Java(Script)/</span><span style="color:#24292F;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( result[</span><span style="color:#0550AE;">0</span><span style="color:#24292F;">] );     </span><span style="color:#6E7781;">// JavaScript（完全匹配）</span></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( result[</span><span style="color:#0550AE;">1</span><span style="color:#24292F;">] );     </span><span style="color:#6E7781;">// Script（第一个分组）</span></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( result.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> ); </span><span style="color:#6E7781;">// 2</span></span>\n<span class="line"></span></code></pre></div><p>嵌套组</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&#39;abcdefg&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/a(b(cd)e)/</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// [&quot;abcde&quot;, &quot;bcde&quot;, &quot;cd&quot;]</span></span>\n<span class="line"></span></code></pre></div><h4 id="阻止分组" tabindex="-1"><a class="header-anchor" href="#阻止分组" aria-hidden="true">#</a> 阻止分组</h4><p>有时我们需要括号才能正确应用量词，但不会引用它，即，既不在 JavaScript API 里引用，也不在正则里反向引用可以通过在开头添加 ?: 来排除组。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> str </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;Gogogo John!&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">// ?: 从捕获组中排除 &#39;go&#39;</span></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> regexp </span><span style="color:#CF222E;">=</span><span style="color:#0A3069;"> /(?:go)</span><span style="color:#CF222E;">+</span><span style="color:#0A3069;"> (</span><span style="color:#0550AE;">\\w</span><span style="color:#CF222E;">+</span><span style="color:#0A3069;">)/</span><span style="color:#CF222E;">i</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> result </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> str.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(regexp);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( result[</span><span style="color:#0550AE;">0</span><span style="color:#24292F;">] ); </span><span style="color:#6E7781;">// Gogogo John（完全匹配）</span></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( result[</span><span style="color:#0550AE;">1</span><span style="color:#24292F;">] ); </span><span style="color:#6E7781;">// John</span></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( result.</span><span style="color:#0550AE;">length</span><span style="color:#24292F;"> ); </span><span style="color:#6E7781;">// 2（数组中没有更多项）</span></span>\n<span class="line"></span></code></pre></div><h3 id="分组命名-name-及引用-n-和-k-name" tabindex="-1"><a class="header-anchor" href="#分组命名-name-及引用-n-和-k-name" aria-hidden="true">#</a> 分组命名 <code>?&lt;name&gt;</code> 及引用：<code>\\N</code> 和 <code>\\k&lt;name&gt;</code></h3><p>默认情况下，正则引擎默认从左到右，以左括号开始为分组编号，可以通过在开始括号之后立即放置 <code>?&lt;name&gt;</code> 来为分组命名</p><p>正则引擎在匹配过程中，给每一个分组都开辟一个空间，用来存储每一个分组匹配到的数据</p><p>使用 <code>$&lt;name&gt;</code> 在 JavaScript 中引用分组匹配的结果</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> regexp </span><span style="color:#CF222E;">=</span><span style="color:#0A3069;"> /(?&lt;</span><span style="color:#24292F;">year</span><span style="color:#0A3069;">&gt;</span><span style="color:#0550AE;">[0-9]</span><span style="color:#CF222E;">{4}</span><span style="color:#0A3069;">)-(?&lt;</span><span style="color:#24292F;">month</span><span style="color:#0A3069;">&gt;</span><span style="color:#0550AE;">[0-9]</span><span style="color:#CF222E;">{2}</span><span style="color:#0A3069;">)-(?&lt;</span><span style="color:#24292F;">day</span><span style="color:#0A3069;">&gt;</span><span style="color:#0550AE;">[0-9]</span><span style="color:#CF222E;">{2}</span><span style="color:#0A3069;">)/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> str </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;2019-10-30, 2020-01-01&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( str.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(regexp, </span><span style="color:#0A3069;">&#39;$&lt;day&gt;.$&lt;month&gt;.$&lt;year&gt;&#39;</span><span style="color:#24292F;">) );</span></span>\n<span class="line"><span style="color:#6E7781;">// 30.10.2019, 01.01.2020</span></span>\n<span class="line"></span></code></pre></div><p>在模式中，使用 <code>\\N</code>、<code>\\k&lt;name&gt;</code> 引来分组匹配的结果，其中 N 是分组编号</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// 获取 引号内的内容</span></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> str </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">`He said: &quot;She&#39;s the one!&quot;.`</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> regexp </span><span style="color:#CF222E;">=</span><span style="color:#0A3069;"> /</span><span style="color:#0550AE;">[&#39;&quot;]</span><span style="color:#0A3069;">(</span><span style="color:#0550AE;">.</span><span style="color:#CF222E;">*?</span><span style="color:#0A3069;">)</span><span style="color:#0550AE;">[&#39;&quot;]</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">// 不是我们想要的结果</span></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( str.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(regexp) ); </span><span style="color:#6E7781;">// &quot;She&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#24292F;">regexp </span><span style="color:#CF222E;">=</span><span style="color:#0A3069;"> /(</span><span style="color:#0550AE;">[&#39;&quot;]</span><span style="color:#0A3069;">)(</span><span style="color:#0550AE;">.</span><span style="color:#CF222E;">*?</span><span style="color:#0A3069;">)</span><span style="color:#CF222E;">\\1</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( str.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(regexp) ); </span><span style="color:#6E7781;">// &quot;She&#39;s the one!&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#24292F;">regexp </span><span style="color:#CF222E;">=</span><span style="color:#0A3069;"> /(?&lt;</span><span style="color:#24292F;">quote</span><span style="color:#0A3069;">&gt;</span><span style="color:#0550AE;">[&#39;&quot;]</span><span style="color:#0A3069;">)(</span><span style="color:#0550AE;">.</span><span style="color:#CF222E;">*?</span><span style="color:#0A3069;">)</span><span style="color:#CF222E;">\\k&lt;</span><span style="color:#24292F;">quote</span><span style="color:#CF222E;">&gt;</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">alert</span><span style="color:#24292F;">( str.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(regexp) ); </span><span style="color:#6E7781;">// &quot;She&#39;s the one!&quot;</span></span>\n<span class="line"></span></code></pre></div><h2 id="正则表达式回溯法原理" tabindex="-1"><a class="header-anchor" href="#正则表达式回溯法原理" aria-hidden="true">#</a> 正则表达式回溯法原理</h2><p>正则表达式回溯法，正则表达式匹配字符串的这种方式，有个学名，叫回溯法。回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。</p><p>本质上就是深度优先搜索算法。<strong>其中退到之前的某一步这一过程</strong>，我们称为“回溯”。从上面的描述过程中，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。</p><p>正则引擎发生回溯主要在以下三种地方</p><ul><li>贪婪量词</li><li>惰性量词</li><li>选择分支符（|）</li></ul><p><strong>贪婪量词下的回溯</strong></p><p><code>&#39;abbbc&#39;.match(/ab{1,3}bbc/)</code>，贪婪模式下，量词已经匹配完所有可能的字符，下一部分模式发现没有字符可匹配到，就会向前要字符，即让出一个字符给下一部分模式进行匹配，总之量词后的部分模式中，只要有没匹配到的字符的，正则引擎就会向前回溯，重新匹配</p><p><img src="'+o+'" alt="贪婪回溯1"></p><p><code>&#39;&quot;abc&quot;de&#39;.match(/&quot;.*&quot;/)</code>，第 8 步中由于没有字符可以匹配 <code>&quot;</code>，故会不断向前回溯匹配</p><p><img src="'+p+'" alt="贪婪回溯2"></p><p><strong>惰性量词下的回溯</strong></p><p><code>&quot;12345&quot;.match(/(\\d{1,3}?)(\\d{1,3})/)</code>，惰性模式下，量词只会先匹配 1 次，只有在模式的剩余部分无法在给定位置匹配时，正则表达式引擎才会增加重复次数</p><p><img src="'+e+'" alt="惰性回溯"></p><p><strong>分支下的回溯</strong></p><p>分支也是具有惰性的，比如 <code>/can|candy/</code>，去匹配字符串 &quot;candy&quot;，得到的结果是 &quot;can&quot;，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。但如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯，例如</p><p><code>/&quot;candy&quot;.match(^(?:can|candy)$/)</code></p><h2 id="选择符" tabindex="-1"><a class="header-anchor" href="#选择符" aria-hidden="true">#</a> 选择符 <code>|</code></h2><p>选择符号<code>|</code>作用并非在字符级别生效，而是在<strong>表达式级别</strong>。</p><ul><li>A|B|C 意思是命中 A、B 或 C 其一均可</li><li>gra|ey 匹配 “gra” or “ey”</li><li>gr(a|e)y 严格等同 gr[ae]y</li></ul><h2 id="练习题" tabindex="-1"><a class="header-anchor" href="#练习题" aria-hidden="true">#</a> 练习题</h2><h4 id="将每个单词的首字母转换为大写" tabindex="-1"><a class="header-anchor" href="#将每个单词的首字母转换为大写" aria-hidden="true">#</a> 将每个单词的首字母转换为大写</h4><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&#39;hello world&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/(?&lt;=</span><span style="color:#CF222E;">\\b</span><span style="color:#0A3069;">)</span><span style="color:#0550AE;">\\w</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">, (</span><span style="color:#953800;">e</span><span style="color:#24292F;">) </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> (e.</span><span style="color:#8250DF;">toUpperCase</span><span style="color:#24292F;">())) </span><span style="color:#6E7781;">// &quot;Hello World&quot;</span></span>\n<span class="line"></span></code></pre></div><h4 id="字符串-trim-方法模拟" tabindex="-1"><a class="header-anchor" href="#字符串-trim-方法模拟" aria-hidden="true">#</a> 字符串 trim 方法模拟</h4><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&quot; foobar &quot;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">^</span><span style="color:#0550AE;">\\s</span><span style="color:#CF222E;">+|</span><span style="color:#0550AE;">\\s</span><span style="color:#CF222E;">+$</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">, </span><span style="color:#0A3069;">&#39;&#39;</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;foobar&quot;</span></span>\n<span class="line"></span></code></pre></div><h4 id="匹配成对标签" tabindex="-1"><a class="header-anchor" href="#匹配成对标签" aria-hidden="true">#</a> 匹配成对标签</h4><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&#39;&lt;title&gt;regular expression&lt;/title&gt; &lt;title&gt;regular expression&lt;/title&gt;&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">match</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/&lt;(</span><span style="color:#0550AE;">.</span><span style="color:#CF222E;">+</span><span style="color:#0A3069;">)&gt;</span><span style="color:#0550AE;">.</span><span style="color:#CF222E;">*?</span><span style="color:#0A3069;">&lt;</span><span style="color:#116329;font-weight:bold;">\\/</span><span style="color:#CF222E;">\\1</span><span style="color:#0A3069;">&gt;/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">)</span></span>\n<span class="line"><span style="color:#6E7781;">// [&quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;, &quot;&lt;title&gt;regular expression&lt;/title&gt;&quot;]</span></span>\n<span class="line"></span></code></pre></div><h4 id="获取-url-pathname" tabindex="-1"><a class="header-anchor" href="#获取-url-pathname" aria-hidden="true">#</a> 获取 URL pathname</h4><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0A3069;">&#39;https://github.com/laoergege/laoergege-blog&#39;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">replace</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">^</span><span style="color:#0A3069;">https</span><span style="color:#CF222E;">?</span><span style="color:#0A3069;">:</span><span style="color:#116329;font-weight:bold;">\\/\\/</span><span style="color:#0550AE;">[</span><span style="color:#CF222E;">^</span><span style="color:#116329;font-weight:bold;">\\/</span><span style="color:#0550AE;">]</span><span style="color:#CF222E;">*</span><span style="color:#0A3069;">/</span><span style="color:#24292F;">, </span><span style="color:#0A3069;">&#39;&#39;</span><span style="color:#24292F;">) </span><span style="color:#6E7781;">// &quot;laoergege/laoergege-blog&quot;</span></span>\n<span class="line"></span></code></pre></div><h4 id="获取-url-中-query-参数" tabindex="-1"><a class="header-anchor" href="#获取-url-中-query-参数" aria-hidden="true">#</a> 获取 url 中 query 参数</h4><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#0550AE;">Array</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">from</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&quot;https://juejin.cn?name=zhangsan&amp;age=18&amp;id=123#&quot;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">matchAll</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/(?&lt;=</span><span style="color:#116329;font-weight:bold;">\\?</span><span style="color:#0A3069;">)</span><span style="color:#0550AE;">[</span><span style="color:#CF222E;">^</span><span style="color:#0550AE;">#]</span><span style="color:#CF222E;">*</span><span style="color:#0A3069;">/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#0550AE;">Array</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">from</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&quot;https://juejin.cn?name=zhangsan&amp;age=18&amp;id=123#&quot;</span><span style="color:#24292F;">.</span><span style="color:#8250DF;">matchAll</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">/</span><span style="color:#116329;font-weight:bold;">\\?</span><span style="color:#0A3069;">(</span><span style="color:#0550AE;">[</span><span style="color:#CF222E;">^</span><span style="color:#0550AE;">#]</span><span style="color:#CF222E;">*</span><span style="color:#0A3069;">)/</span><span style="color:#CF222E;">g</span><span style="color:#24292F;">)) </span></span>\n<span class="line"></span></code></pre></div><h2 id="参考阅读" tabindex="-1"><a class="header-anchor" href="#参考阅读" aria-hidden="true">#</a> 参考阅读</h2>',72),d={href:"https://link.zhihu.com/?target=https%3A//github.com/qdlaoyao/js-regex-mini-book",target:"_blank",rel:"noopener noreferrer"},E=(0,n.Uk)("JavaScript 正则表达式迷你书"),u={href:"https://zh.javascript.info/regular-expressions",target:"_blank",rel:"noopener noreferrer"},h=(0,n.Uk)("正则表达式"),F=(0,n.uE)('<h2 id="js-正则、字符串相关方法" tabindex="-1"><a class="header-anchor" href="#js-正则、字符串相关方法" aria-hidden="true">#</a> JS 正则、字符串相关方法</h2><ul><li>str.match(regexp) <ul><li>不带 g，返回 <code>[match, p1, p2, ..., pn, offset, input, groups]</code></li><li>带 g，不对匹配结果继续分组，返回 [match1, match2, ...]</li><li>如果没有匹配项则返回 null</li></ul></li><li>str.matchAll(regexp) <ul><li>返回一个可迭代的对象</li><li>必须带 g，转数组为 <code>[[match, p1, p2, ..., pn, offset, input, groups], ...]</code></li></ul></li><li>str.replace(str|regexp, str|func) <ul><li>func(match, p1, p2, ..., pn, offset, input, groups)</li></ul></li><li>str.split(regexp|substr, limit)</li><li>str.search(regexp)</li><li>regexp.exec(str)</li><li>regexp.test(str)</li></ul>',2),g={},A=(0,l(3860).Z)(g,[["render",function(s,a){const l=(0,n.up)("ExternalLinkIcon");return(0,n.wg)(),(0,n.iD)("div",null,[t,(0,n._)("blockquote",null,[(0,n._)("p",null,[c,(0,n._)("a",r,[i,(0,n.Wm)(l)])])]),y,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",d,[E,(0,n.Wm)(l)])]),(0,n._)("li",null,[(0,n._)("a",u,[h,(0,n.Wm)(l)])])]),F])}]])},3860:(s,a)=>{a.Z=(s,a)=>{const l=s.__vccOpts||s;for(const[s,n]of a)l[s]=n;return l}}}]);