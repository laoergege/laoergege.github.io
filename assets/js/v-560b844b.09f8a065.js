"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[7896],{3073:(s,a,n)=>{n.r(a),n.d(a,{data:()=>l});const l={key:"v-560b844b",path:"/JavaScript/JavaScript%20%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.html",title:"JavaScript 代码执行机制",lang:"zh-CN",frontmatter:{release:!0,tags:["javascript"],description:"总结 JavaScript 代码执行过程中主要机制，如变量提升、调用栈、必报、执行上下文及作用域链。"},excerpt:"",headers:[{level:2,title:"变量提升",slug:"变量提升",children:[{level:3,title:"变量声明的提升行为",slug:"变量声明的提升行为",children:[]}]},{level:2,title:"调用栈",slug:"调用栈",children:[]},{level:2,title:"作用域",slug:"作用域",children:[{level:3,title:"let、const 声明的块级作用域原理及暂时性死区",slug:"let、const-声明的块级作用域原理及暂时性死区",children:[]},{level:3,title:"暂时性死区（TDZ）",slug:"暂时性死区-tdz",children:[]}]},{level:2,title:"作用域链",slug:"作用域链",children:[]},{level:2,title:"闭包",slug:"闭包",children:[{level:3,title:"闭包实现原理",slug:"闭包实现原理",children:[]},{level:3,title:"eval 下的闭包",slug:"eval-下的闭包",children:[]},{level:3,title:"闭包缺点",slug:"闭包缺点",children:[]}]},{level:2,title:"this 指针",slug:"this-指针",children:[{level:3,title:"this 指向",slug:"this-指向",children:[]}]}],git:{createdTime:1635525796e3,updatedTime:1665411796e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:14}]}}},9292:(s,a,n)=>{n.r(a),n.d(a,{default:()=>A});var l=n(5393);const p=n.p+"assets/img/88c7ce0dcf04f89a50e15ea72293ca242378e4b35486d2b2de6a1c2b1b7ad998.c4d10581.png",o=n.p+"assets/img/733bc7f970934ca264426d36b79f605cc41a41a9f2d1109ecb61c03ce0681f22.4660ce91.png",e=n.p+"assets/img/9d1ff0fa83857785c90abd14974958ea964190751a17a38c061ff4823e205585.38698829.png",c=n.p+"assets/img/20bc07b5deed579457df4f5dfc2281e1643f2a5d9b26fc1c4549a5b0ee419813.8afb62b7.png",t=n.p+"assets/img/4045250b79269be3fb95da41a366f055a60a03c88331a333d2d8737bc963ca24.96ddf501.png",r=n.p+"assets/img/db09c4e7adfde3898f824d5b5572639d585af3402a3a396419c1dabe2c8372e1.3bae74fa.png",i=n.p+"assets/img/2f43f90a426f1669a1aa590d59363ed7202bd15f0d4cabf28489af944acedba3.f19b29cb.png",y=n.p+"assets/img/b5a8dad980822faf751e18fca305d4dff5a6292816a1a53b0c67e4b228d00316.76df5075.png",F=n.p+"assets/img/closure-eval.eddfc1df.png",d=n.p+"assets/img/5c16478b0d56c37b0a8cd4b26a46cec28c7e828aa3e949e9962db9dbe57a24a5.1b7bb327.png",f=n.p+"assets/img/0e0b49e0cc45d950e4c501bdf06e1e462963953279126406b2d4db49f7af613c.877a64e0.png",u=(0,l.uE)('<h1 id="javascript-代码执行机制" tabindex="-1"><a class="header-anchor" href="#javascript-代码执行机制" aria-hidden="true">#</a> JavaScript 代码执行机制</h1><ul><li>JavaScript 代码执行机制 <ul><li><a href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">变量提升</a></li><li><a href="#%E8%B0%83%E7%94%A8%E6%A0%88">调用栈</a></li><li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li><li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">作用域链</a></li><li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li><li>执行上下文 <ul><li>变量环境 <ul><li>arguments</li><li>变量声明</li><li>函数声明</li></ul></li><li>词法环境</li><li>作用域链</li><li><a href="#this-%E6%8C%87%E9%92%88">this</a></li></ul></li></ul></li></ul><h2 id="变量提升" tabindex="-1"><a class="header-anchor" href="#变量提升" aria-hidden="true">#</a> 变量提升</h2><p>所谓的变量提升，相当于代码执行之前 JavaScript 引擎把<strong>变量的声明部分和函数的声明部分</strong>提升到代码开头的“行为”。</p><p><img src="'+p+'" alt="图 3"></p><p><strong>变量提升，发生在 JavaScript 代码编译阶段。实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中</strong>。一段 JavaScript 经过编译后，会生成两部分内容：<strong>执行上下文（Execution context）和可执行代码（会被编译为字节码）</strong>。</p><p><img src="'+o+'" alt="图 4"></p><ul><li>执行上下文是 JavaScript 执行一段代码时的运行环境</li><li>执行上下文中存在一个变量环境的对象（Viriable Environment）</li><li>变量环境的对象保存了变量提升的内容</li></ul><p>有了执行上下文和可执行代码了，那么接下来就到了执行阶段了，JavaScript 引擎会从执行上下文中的变量环境去查找自定义的变量和函数。</p><h3 id="变量声明的提升行为" tabindex="-1"><a class="header-anchor" href="#变量声明的提升行为" aria-hidden="true">#</a> 变量声明的提升行为</h3><p>所有的声明 function、var、let、const 和 class 都会在 JavaScript 编译期间被提升。</p><ul><li>var <ul><li>var 声明永远作用于脚本、模块和函数体这个级别</li><li>初始为 undefined</li></ul></li><li>class、let、const <ul><li>块级作用域</li><li>未初始化，暂存性死区</li></ul></li><li>function <ul><li>作用域：脚本、模块、函数体、块级</li><li>初始赋值 <ul><li>如果一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数</li><li>如果函数声明名称跟变量名相同，函数声明优先</li></ul></li><li>ES6 支持函数块级声明： <ul><li>提升到块外，行为类似 var，且初始为 undefined</li><li>块内提升行为类似原 ES5 Function<div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(f); </span><span style="color:#6E7781;">// outside f</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">f</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&quot;I am outside!&quot;</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#24292F;">  (</span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> () {</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(f); </span><span style="color:#6E7781;">// undefined</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span><span style="color:#0550AE;">true</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">      console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(f); </span><span style="color:#6E7781;">// inside f</span></span>\n<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">f</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">        console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&quot;I am inside!&quot;</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">      }</span></span>\n<span class="line"><span style="color:#24292F;">    }</span></span>\n<span class="line"><span style="color:#24292F;">  })();</span></span>\n<span class="line"></span></code></pre></div></li></ul></li></ul></li></ul><h2 id="调用栈" tabindex="-1"><a class="header-anchor" href="#调用栈" aria-hidden="true">#</a> 调用栈</h2><p>执行上下文是 JavaScript 代码的运行环境，JavaScript 代码是分一段段执行的，每一段代码执行都分为两个阶段：</p><ul><li>编译阶段（创建对应的执行上下文，进行变量提升）</li><li>执行阶段</li></ul><p>哪些情况下一段代码才会创建执行上下文？一般说来，有这么三种情况：</p><ul><li>全局代码</li><li>模块代码（ES6）</li><li>函数代码</li><li>eval 执行的代码</li></ul><p>大多数命令式编程语言都支持过程式调用，都使用栈的数据结构来动态管理代码之间的嵌套调用关系。</p><p><img src="'+e+'" alt="图 5"></p><p>JavaScript 引擎也是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称<strong>调用栈</strong>。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">multiply</span><span style="color:#24292F;">(</span><span style="color:#953800;">x</span><span style="color:#24292F;">, </span><span style="color:#953800;">y</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> x </span><span style="color:#CF222E;">*</span><span style="color:#24292F;"> y;</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">printSquare</span><span style="color:#24292F;">(</span><span style="color:#953800;">x</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> s </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">multiply</span><span style="color:#24292F;">(x, x);</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(s);</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">printSquare</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">5</span><span style="color:#24292F;">);</span></span>\n<span class="line"></span></code></pre></div><p><img src="'+c+'" alt="图 9"></p><p>其中</p><ol><li>调用栈底是全局执行上下文</li><li>当前函数执行完毕后，栈顶该函数的执行上下文会被弹出栈</li></ol><p>那么调用栈有什么用？</p><ul><li>追踪代码调用的执行轨迹</li><li>栈内存管理更方便快捷</li></ul><h2 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h2><blockquote><p>作用域只是一个概念，你可以想象理解成一圈套一圈的样子，而执行上下文是 JS 引擎具体实现的东西，切勿混淆。</p></blockquote><p><strong>作用域控制变量的可见范围和生命周期</strong>。作用域是让一个变量（甚至表达式）具有逻辑边界意义，让我们能够在一个程序中使用多个具有相同命名的变量，而且它们每个都可能有不同的含义和值。</p><p>JavaScript 是词法（静态）作用域，变量的作用域在编译时静态确定，根据变量在实际源码结构中位置划分所属作用域。一般作用域划分分为</p><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域（下面介绍）</li></ul><p>早期还使用 IIFE 来模拟产生“块级作用域”：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">//es6中的块级作用域</span></span>\n<span class="line"><span style="color:#24292F;">{</span></span>\n<span class="line"><span style="color:#24292F;"> </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> a </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;"> console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(a);</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(a); </span><span style="color:#6E7781;">//ReferenceError</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">//IIFE实现</span></span>\n<span class="line"><span style="color:#24292F;">(</span><span style="color:#CF222E;">function</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> a </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(a);</span></span>\n<span class="line"><span style="color:#24292F;">})();</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(a); </span><span style="color:#6E7781;">//Undefined</span></span>\n<span class="line"></span></code></pre></div><h3 id="let、const-声明的块级作用域原理及暂时性死区" tabindex="-1"><a class="header-anchor" href="#let、const-声明的块级作用域原理及暂时性死区" aria-hidden="true">#</a> let、const 声明的块级作用域原理及暂时性死区</h3><p>在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。</p><p>而 var 声明的变量具有全局或者函数级别作用域，因为变量提升机制，使得变量声明都被提升到函数顶部或者全局，这就导致 JavaScript 的代码并不像其他语言直观。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(myname); </span><span style="color:#6E7781;">// undefined</span></span>\n<span class="line"><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myname </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;极客时间&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">showName</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span><span style="color:#0550AE;">true</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myname </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;极客邦&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">  }</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(myname); </span><span style="color:#6E7781;">// &quot;极客邦&quot;</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"><span style="color:#8250DF;">showName</span><span style="color:#24292F;">();</span></span>\n<span class="line"></span></code></pre></div><p>而且变量容易在不被察觉的情况下被覆盖掉</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myname </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;极客时间&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">showName</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(myname); </span><span style="color:#6E7781;">// undefined</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">if</span><span style="color:#24292F;"> (</span><span style="color:#0550AE;">true</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myname </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;极客邦&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">  }</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(myname); </span><span style="color:#6E7781;">// 极客邦</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"><span style="color:#8250DF;">showName</span><span style="color:#24292F;">();</span></span>\n<span class="line"></span></code></pre></div><p>本应销毁的变量没有被销毁</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">for</span><span style="color:#24292F;"> (</span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> i </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;">; i </span><span style="color:#CF222E;">&lt;=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">5</span><span style="color:#24292F;">; i</span><span style="color:#CF222E;">++</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#0550AE;">setTimeout</span><span style="color:#24292F;">(</span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> () {</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(i); </span><span style="color:#6E7781;">// 5 5 5 5 5</span></span>\n<span class="line"><span style="color:#24292F;">  }, </span><span style="color:#0550AE;">0</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"></span></code></pre></div><p>早期使用 “立即执行的函数表达式（IIFE）”来产生“块级作用域”。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// IIFE 闭包</span></span>\n<span class="line"><span style="color:#CF222E;">for</span><span style="color:#24292F;"> (</span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> i </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;">; i </span><span style="color:#CF222E;">&lt;=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">5</span><span style="color:#24292F;">; i</span><span style="color:#CF222E;">++</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">  (</span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> (</span><span style="color:#953800;">j</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#0550AE;">setTimeout</span><span style="color:#24292F;">(</span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">timer</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">      console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(j); </span><span style="color:#6E7781;">// 1 2 3 4 5</span></span>\n<span class="line"><span style="color:#24292F;">    }, </span><span style="color:#0550AE;">0</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">  })(i);</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"></span></code></pre></div><p>ES6 引入了 let 和 const 关键字作为块级作用域变量声明，同时为了保证向下兼容，ES6 在执行上下文新增加了<strong>词法环境</strong>。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">foo</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> a </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> b </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">2</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">  {</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> b </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">3</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> c </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">4</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> d </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">5</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(a);</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(b);</span></span>\n<span class="line"><span style="color:#24292F;">  }</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(b);</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(c);</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(d);</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"><span style="color:#8250DF;">foo</span><span style="color:#24292F;">();</span></span>\n<span class="line"></span></code></pre></div><p>词法环境内部，维护了一个小型栈结构，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶，<strong>JavaScript 查找变量时沿着词法环境的栈顶向下查询，然后变量环境</strong>。</p><p><img src="'+t+'" alt="图 6"></p><h3 id="暂时性死区-tdz" tabindex="-1"><a class="header-anchor" href="#暂时性死区-tdz" aria-hidden="true">#</a> 暂时性死区（TDZ）</h3><p><strong>由于变量提升机制，所有的声明（function、var、let、const 和 class）都在 JavaScript 编译期间被提升，而 var 声明的变量提升会被初始化为 undefined，而 let 和 const 则未初始化</strong>。</p><p>只有在 JavaScript 引擎在执行源代码中声明的位置时，它们才会被初始化。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> a; </span><span style="color:#6E7781;">// 如果声明语句没有初始化赋值则默认 undefined</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(a); </span><span style="color:#6E7781;">// outputs undefined</span></span>\n<span class="line"><span style="color:#24292F;">a </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">5</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span></code></pre></div><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(a); </span><span style="color:#6E7781;">// ReferenceError: a is not defined</span></span>\n<span class="line"><span style="color:#CF222E;">let</span><span style="color:#24292F;"> a </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">3</span><span style="color:#24292F;">;</span></span>\n<span class="line"></span></code></pre></div><p>这意味着在引擎在源代码中声明的位置之前，您无法访问该变量，因为该变量还未初始化。这就是我们所说的“临时死区”，变量创建和初始化之间的时间跨度，在那里它们不能被访问。</p><p>总之暂时性死区的就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是在变量执行声明语句之前都不可以访问。</p>',54),E=(0,l.Uk)("推荐阅读 "),g={href:"https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda",target:"_blank",rel:"noopener noreferrer"},h=(0,l.Uk)("Hoisting in Modern JavaScript — let, const, and var"),v=(0,l.uE)('<p>除了块级作用域以外，函数参数默认值也会受到 TDZ 影响。</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">foo</span><span style="color:#24292F;">(</span><span style="color:#953800;">arg1</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> arg2, </span><span style="color:#953800;">arg2</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// let arg1 = xxx || arg2</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#6E7781;">// let arg2 = xxx</span></span>\n<span class="line"><span style="color:#24292F;">  console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">`${</span><span style="color:#24292F;">arg1</span><span style="color:#0A3069;">} ${</span><span style="color:#24292F;">arg2</span><span style="color:#0A3069;">}`</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#8250DF;">foo</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">undefined</span><span style="color:#24292F;">, </span><span style="color:#0A3069;">&quot;arg2&quot;</span><span style="color:#24292F;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">// Uncaught ReferenceError: arg2 is not defined</span></span>\n<span class="line"></span></code></pre></div><h2 id="作用域链" tabindex="-1"><a class="header-anchor" href="#作用域链" aria-hidden="true">#</a> 作用域链</h2><p>作用域与作用域形成<strong>嵌套</strong>关系，<strong>内层作用域能够访问外层作用域的变量</strong>，当前作用域查找不到就会往外层作用域进行查找，依次类推，这一条查找链路就是作用域链。</p><p>以下是 JavaScript 词法作用域形成的作用域链：</p><p><img src="'+r+'" alt="图 10"></p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><blockquote><p>闭包形成的本质：词法作用域 + 函数是一等公民</p></blockquote><p>在 JavaScript 中，闭包就是绑定了执行环境（作用域链）的函数。</p><p>根据词法作用域原则，内层函数中访问到其外层函数的作用域。但是 JavaScript 中函数是一等公民，函数也可以作为变量赋值，意味着函数可以脱离当前作用域在其他作用域被调用。这时就需要将内部函数引用到的外部作用域变量保留下来，跟该函数关联起来，以便引擎执行该函数代码能够继续查找到原词法位置中外部的变量。</p><blockquote><p>如果仅仅是词法作用域，那么嵌套函数调用关系可以用调用栈去表示并且根据调用栈去查找变量。</p></blockquote><blockquote><p>闭包的形成时是在编译期间，跟函数动态调用栈没什么关系。</p></blockquote><h3 id="闭包实现原理" tabindex="-1"><a class="header-anchor" href="#闭包实现原理" aria-hidden="true">#</a> 闭包实现原理</h3><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">foo</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myName </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;极客时间&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> test1 </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">1</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">const</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">test2</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">2</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> innerBar </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> {</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">setName</span><span style="color:#24292F;">: </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> (</span><span style="color:#953800;">newName</span><span style="color:#24292F;">) {</span></span>\n<span class="line"><span style="color:#24292F;">      myName </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> newName;</span></span>\n<span class="line"><span style="color:#24292F;">    },</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">getName</span><span style="color:#24292F;">: </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> () {</span></span>\n<span class="line"><span style="color:#24292F;">      console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(test1);</span></span>\n<span class="line"><span style="color:#24292F;">      </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> myName;</span></span>\n<span class="line"><span style="color:#24292F;">    },</span></span>\n<span class="line"><span style="color:#24292F;">  };</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#CF222E;">return</span><span style="color:#24292F;"> innerBar;</span></span>\n<span class="line"><span style="color:#24292F;">}</span></span>\n<span class="line"><span style="color:#CF222E;">var</span><span style="color:#24292F;"> bar </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">foo</span><span style="color:#24292F;">();</span></span>\n<span class="line"><span style="color:#24292F;">bar.</span><span style="color:#8250DF;">setName</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&quot;极客邦&quot;</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">bar.</span><span style="color:#8250DF;">getName</span><span style="color:#24292F;">();</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(bar.</span><span style="color:#8250DF;">getName</span><span style="color:#24292F;">());</span></span>\n<span class="line"></span></code></pre></div><ol><li>当在编译 foo 函数过程中，遇到内部函数 setName，JavaScript 引擎会<strong>对内部函数做一次快速的词法扫描</strong>，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个 <code>closure(foo)</code> 的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量，<code>closure(foo)</code> 保存在 setName 的作用域链属性 <code>[[scopes]]</code> 上。</li><li>接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到<code>[[scopes]]</code>对象中。这时候堆中的<code>[[scopes]]</code>对象中就包含了 myName 和 test1 两个变量了。</li><li>由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中，当调用结束，test2 也就会被销毁。</li><li>当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用 <code>clourse(foo)</code> 对象，所以即使 foo 函数退出了，<strong><code>clourse(foo)</code>依然被其内部的 getName 和 setName 方法引用</strong>。所以在下次调用 bar.setName 或者 bar.getName 时，通过作用域链上的 <code>clourse(foo)</code> 找到相应变量。</li></ol><p><img src="'+i+'" alt="图 2"></p><p><code>closure(foo)</code> 只会保留使用到的变量。</p><p><img src="'+y+'" alt="图 3"></p><p>通过作用域链上的 <code>clourse(foo)</code> 找到相应变量。</p><p>总的来说，产生闭包的核心有两步：</p><ol><li>第一步是需要预扫描内部函数；</li><li>第二步是把内部函数引用的外部变量保存到堆中。</li></ol><h3 id="eval-下的闭包" tabindex="-1"><a class="header-anchor" href="#eval-下的闭包" aria-hidden="true">#</a> eval 下的闭包</h3><p>一般情况下会预扫描内部函数只保存内部需要的变量，但 eval 执行的是动态脚本无法静态分析，这会导致闭包会把<strong>外层作用域的变量全保存</strong>！</p><p><img src="'+F+'" alt=""></p><h3 id="闭包缺点" tabindex="-1"><a class="header-anchor" href="#闭包缺点" aria-hidden="true">#</a> 闭包缺点</h3><p><img src="'+d+'" alt="图 2"></p><p>发现多层嵌套情况下，内部函数闭包的形成会在外部函数作用域链的基础上继续扩展。</p><p>闭包是外部函数的变量集合，保存在堆里，如果闭包使用不正确，会很容易造成内存泄漏的。</p><blockquote><p>内存泄漏是指内存空间明明已经不再被使用，但由于某种原因并没有被释放的现象。</p></blockquote>',29),b=(0,l.Uk)("JavaScript 内存管理机制"),m=(0,l.Uk)(" 了解 JavaScript 是如何回收内存。"),C=(0,l.uE)('<p>因为函数是一等公民，函数引用可以被传递到处使用，如果引用闭包的函数是个局部变量，那么等函数销毁后，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。如果外部变量保持引用活着，那么就会一直占用内存，可能造成内存泄漏。</p><blockquote><p>相比较传统面对象编程 Java，函数只是对象的方法，被限制在对象这个域里 🤔</p></blockquote><h2 id="this-指针" tabindex="-1"><a class="header-anchor" href="#this-指针" aria-hidden="true">#</a> this 指针</h2><p>JavaScirpt 函数的变量查找机制有两种：</p><ul><li>作用域链机制</li><li>this（原型链机制）</li></ul><p>this 存在执行上下文中</p><p><img src="'+f+'" alt="图 9"></p><h3 id="this-指向" tabindex="-1"><a class="header-anchor" href="#this-指向" aria-hidden="true">#</a> this 指向</h3><p>this 的指向，是在调用函数时根据执行上下文所动态确定的。</p><p>而函数使用一半存在以下几种：</p><ul><li>直接调用 <ul><li>默认情况下普通函数执行上下文中的 this 是指向全局对象 window</li><li>严格模式下，this 值则是 undefined</li></ul></li><li>对象方法调用（指向该对象）</li><li>call、bind、apply（指向传入的参数对象）</li><li>构造函数（this 指向新创建的对象）</li><li>箭头函数（执行上下文没有 this，依靠作用域链继承外层作用域的 this）</li></ul><p>题目</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#6E7781;">// 嵌套函数中的 this 不会从外层函数中继承</span></span>\n<span class="line"><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myObj </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> {</span></span>\n<span class="line"><span style="color:#24292F;">  name: </span><span style="color:#0A3069;">&quot;极客时间&quot;</span><span style="color:#24292F;">,</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#8250DF;">showThis</span><span style="color:#24292F;">: </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> () {</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">this</span><span style="color:#24292F;">); </span><span style="color:#6E7781;">// myObj</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">bar</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">      console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">this</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">    } </span><span style="color:#6E7781;">// window</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">bar</span><span style="color:#24292F;">();</span></span>\n<span class="line"><span style="color:#24292F;">  },</span></span>\n<span class="line"><span style="color:#24292F;">};</span></span>\n<span class="line"><span style="color:#24292F;">myObj.</span><span style="color:#8250DF;">showThis</span><span style="color:#24292F;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">// 缓存 this</span></span>\n<span class="line"><span style="color:#6E7781;">// 把 this 体系转换为了作用域的体系，通过作用域链去继承</span></span>\n<span class="line"><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myObj </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> {</span></span>\n<span class="line"><span style="color:#24292F;">  name: </span><span style="color:#0A3069;">&quot;极客时间&quot;</span><span style="color:#24292F;">,</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#8250DF;">showThis</span><span style="color:#24292F;">: </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> () {</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">this</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> self </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0550AE;">this</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">bar</span><span style="color:#24292F;">() {</span></span>\n<span class="line"><span style="color:#24292F;">      self.name </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;极客邦&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">    }</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">bar</span><span style="color:#24292F;">();</span></span>\n<span class="line"><span style="color:#24292F;">  },</span></span>\n<span class="line"><span style="color:#24292F;">};</span></span>\n<span class="line"><span style="color:#24292F;">myObj.</span><span style="color:#8250DF;">showThis</span><span style="color:#24292F;">();</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(myObj.name);</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(window.name);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6E7781;">// 箭头函数</span></span>\n<span class="line"><span style="color:#6E7781;">// ES6 中的箭头函数其自身的执行上下文没有 this，所以箭头函数中的 this 取决于它的外部函数。</span></span>\n<span class="line"><span style="color:#CF222E;">var</span><span style="color:#24292F;"> myObj </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> {</span></span>\n<span class="line"><span style="color:#24292F;">  name: </span><span style="color:#0A3069;">&quot;极客时间&quot;</span><span style="color:#24292F;">,</span></span>\n<span class="line"><span style="color:#24292F;">  </span><span style="color:#8250DF;">showThis</span><span style="color:#24292F;">: </span><span style="color:#CF222E;">function</span><span style="color:#24292F;"> () {</span></span>\n<span class="line"><span style="color:#24292F;">    console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">this</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">var</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">bar</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> () </span><span style="color:#CF222E;">=&gt;</span><span style="color:#24292F;"> {</span></span>\n<span class="line"><span style="color:#24292F;">      </span><span style="color:#0550AE;">this</span><span style="color:#24292F;">.name </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#0A3069;">&quot;极客邦&quot;</span><span style="color:#24292F;">;</span></span>\n<span class="line"><span style="color:#24292F;">      console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(</span><span style="color:#0550AE;">this</span><span style="color:#24292F;">);</span></span>\n<span class="line"><span style="color:#24292F;">    };</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#8250DF;">bar</span><span style="color:#24292F;">();</span></span>\n<span class="line"><span style="color:#24292F;">  },</span></span>\n<span class="line"><span style="color:#24292F;">};</span></span>\n<span class="line"><span style="color:#24292F;">myObj.</span><span style="color:#8250DF;">showThis</span><span style="color:#24292F;">();</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(myObj.name);</span></span>\n<span class="line"><span style="color:#24292F;">console.</span><span style="color:#8250DF;">log</span><span style="color:#24292F;">(window.name);</span></span>\n<span class="line"></span></code></pre></div>',13),D={},A=(0,n(3860).Z)(D,[["render",function(s,a){const n=(0,l.up)("ExternalLinkIcon"),p=(0,l.up)("RouterLink");return(0,l.wg)(),(0,l.iD)("div",null,[u,(0,l._)("blockquote",null,[(0,l._)("p",null,[E,(0,l._)("a",g,[h,(0,l.Wm)(n)])])]),v,(0,l._)("blockquote",null,[(0,l._)("p",null,[(0,l.Wm)(p,{to:"/JavaScript/JavaScript%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6.html"},{default:(0,l.w5)((()=>[b])),_:1}),m])]),C])}]])},3860:(s,a)=>{a.Z=(s,a)=>{const n=s.__vccOpts||s;for(const[s,l]of a)n[s]=l;return n}}}]);