"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[838],{8279:(e,s,l)=>{l.r(s),l.d(s,{data:()=>a});const a={key:"v-54e51afe",path:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8AHTTP/https.html",title:"HTTPS",lang:"zh-CN",frontmatter:{release:!0,top:4,tags:["http","https","tls","ssl"],desc:"对 https 原理的一个大致了解。"},excerpt:"",headers:[{level:2,title:"SSL/TLS",slug:"ssl-tls",children:[{level:3,title:"加密套件",slug:"加密套件",children:[]}]},{level:2,title:"https 安全原理",slug:"https-安全原理",children:[{level:3,title:"对称加密",slug:"对称加密",children:[]},{level:3,title:"非对称加密",slug:"非对称加密",children:[]},{level:3,title:"混合加密",slug:"混合加密",children:[]},{level:3,title:"数字证书和 CA 机构组成的证书信任链",slug:"数字证书和-ca-机构组成的证书信任链",children:[]},{level:3,title:"https 安全原理总结",slug:"https-安全原理总结",children:[]}]},{level:2,title:"TLS 连接",slug:"tls-连接",children:[{level:3,title:"RSA 握手",slug:"rsa-握手",children:[]},{level:3,title:"ECDHE 握手过程",slug:"ecdhe-握手过程",children:[]}]},{level:2,title:"TLS/1.3",slug:"tls-1-3",children:[{level:3,title:"扩展协议",slug:"扩展协议",children:[]},{level:3,title:"强化安全、简化密码套件",slug:"强化安全、简化密码套件",children:[]},{level:3,title:"提升性能：1-RTT 握手",slug:"提升性能-1-rtt-握手",children:[]}]},{level:2,title:"学习参考",slug:"学习参考",children:[]}],git:{createdTime:1664433214e3,updatedTime:1664433214e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:1}]}}},6178:(e,s,l)=>{l.r(s),l.d(s,{default:()=>k});var a=l(5393);const n=l.p+"assets/img/266e6a36239b598f1baa5333f52f6c41503c66538440fbea035c44f3f386306e.629f3cd0.png",p=l.p+"assets/img/1660873486128.dfbc9b5d.png",r=l.p+"assets/img/1660877165877.08dfa6e4.png",i=l.p+"assets/img/1648394387393.f5fb5ac9.png",t=l.p+"assets/img/1648394415188.d0deaada.png",o=l.p+"assets/img/1650960138695.be503c44.png",c=l.p+"assets/img/1650959174145.8aad4e74.png",h=l.p+"assets/img/1650900031714.020e3329.png",d=l.p+"assets/img/1650987278663.cc0a746e.png",u=l.p+"assets/img/1650988382793.35e86c87.png",S=(0,a.uE)('<h1 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h1><p>https 与 http 相比较</p><ul><li>在 HTTP 协议栈中引入安全协议层（对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作）</li><li>端口由默认的 80 改为 443</li></ul><p><img src="'+n+'" alt="图 9"></p><p>SSL/TLS 为 http 增加了四个安全特性：</p><ul><li>机密性，只能由可信的人访问，对其他人是不可见</li><li>完整性，数据在传输过程中没有被篡改</li><li>身份认证，确认对方的真实身份</li><li>不可否认，也叫不可抵赖。</li></ul><h2 id="ssl-tls" tabindex="-1"><a class="header-anchor" href="#ssl-tls" aria-hidden="true">#</a> SSL/TLS</h2><p>SSL 即安全套接层（Secure Sockets Layer），后改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。到目前为止，应用的最广泛的 TLS 是 1.2。</p><p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p><blockquote><p>OpenSSL 是著名的开源密码学程序库和工具包，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等</p></blockquote><h3 id="加密套件" tabindex="-1"><a class="header-anchor" href="#加密套件" aria-hidden="true">#</a> 加密套件</h3><p>TLS/SSL 采用<strong>多种先进的加密技术保证通信安全</strong>，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件），密码套件命名非常规范，格式很固定。基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”。比如</p><p>“TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256”：</p><p>握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证（摘要认证）和伪随机函数产生随机数。</p><h2 id="https-安全原理" tabindex="-1"><a class="header-anchor" href="#https-安全原理" aria-hidden="true">#</a> https 安全原理</h2><p>因为 http 的内容是明文传输的，明文数据会经过“中间人”，容易被篡改，而 https 对明文数据进行了加密，使用了混合加密的方式，即对称加密和非对称加密的组合使用。</p><h3 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h3><p>通信双方都各自持有同一个密钥，这样就可以加密解密，且别人不知道。</p><p><img src="images/0c5cacbaa052f909ca632cbffc328b3e279878bced93a24db38a622927341110.png" alt="图 11"></p><p>但 http 是明文传输，那么如何把密钥安全地传递给对方？</p><h3 id="非对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a> 非对称加密</h3><p>非对称加密，使用两把密钥：公钥、私钥，公钥可以公开给任何人使用，而私钥必须严格保密，外部使用公钥加密的内容只能由私钥解开。</p><p><img src="images/f13246de24c73a99f530ed7ca59599d0d363104889cdb3bf108251f36fb69f30.png" alt="图 12"></p><p>服务器会将其中的一个公钥通过明文的形式发送给浏览器，浏览器通过公钥加密的内容只有服务器才能解密看到。</p><h3 id="混合加密" tabindex="-1"><a class="header-anchor" href="#混合加密" aria-hidden="true">#</a> 混合加密</h3><p>混合加密，简单说通信双方通过非对称加密协商出一个用于对称加密的密钥，因为<strong>非对称加密算法非常耗时，而对称加密快很多</strong>，所以使用非对称加密方式传输对称加密的密钥。流程如下：</p><ol><li>服务器发送公钥</li><li>客户端生成对称加密的密钥，用服务度公钥加密传送给服务端</li><li>服务端利用私钥进行解密</li><li>后续用客户端的对称加密的密钥与客户端通信</li></ol><p>虽然保证机密性，但却还不够安全，比如中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，你拿到了假的公钥，你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。</p><p>那么如何证明浏览器收到的公钥一定是该网站的公钥？</p><h3 id="数字证书和-ca-机构组成的证书信任链" tabindex="-1"><a class="header-anchor" href="#数字证书和-ca-机构组成的证书信任链" aria-hidden="true">#</a> 数字证书和 CA 机构组成的证书信任链</h3><p>第三方信任机构，对网站颁发的“身份证”，也就是数字证书。数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器根据证书匹配下信息并从里获取公钥就行了。</p><p>但证书本身的传输也是明文的，如何防止被篡改以及证书信任问题？</p><ol><li>数字证书的数字签名及验证</li><li>证书信任链</li></ol><h4 id="数字签名及验证" tabindex="-1"><a class="header-anchor" href="#数字签名及验证" aria-hidden="true">#</a> 数字签名及验证</h4><p>数字签名，就是数字证书的“防伪技术”。其实原理就是用私钥对证书签名，<strong>因为只有私钥加密的东西公钥才能解密，也就能对应认证对方身份</strong>。</p><p><img src="images/a5a0dc09e32b91676e6d0105be4a8978279c3edc32bc26cff18f43aada58647a.png" alt="图 13"></p><p>数字签名的制作过程：</p><ol><li>CA机构拥有非对称加密的私钥和公钥。</li><li>CA机构对证书明文数据进行摘要算法（也就是 hash 算法）。</li><li>对 hash 值用私钥加密，得到数字签名（摘要算法虽然保证了证书内容的完整性，但是摘要也是明文传输，中间人也可能一起篡改）</li></ol><blockquote><p>有了加密，为什么制作数字签名时需要hash一次？<br> 非对称加密效率较差，hash后得到的是固定长度的信息，对 hash 加解密就快很多。</p></blockquote><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，签名S。</li><li>用 CA 机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到 hash 值</li><li>用证书里指明的摘要算法对证书明文进行 hash</li><li>对比两者 hash 值，相等则表明证书可信</li></ol><p><img src="'+p+'" alt="图 2"></p><h4 id="证书信任链" tabindex="-1"><a class="header-anchor" href="#证书信任链" aria-hidden="true">#</a> 证书信任链</h4><p>除了要解决服务器的信任，还要解决签发机构的信任，再引入一个第三方机构？然后又染后？如此套娃，恐怕不行。</p><p>将颁发证书的机构划分为两种类型，根 CA(Root CAs)和中间 CA(Intermediates CAs)，通常申请者都是向中间 CA 去申请证书的，而根 CA 作用就是给中间 CA 做认证，一个根 CA 会认证很多中间的 CA，而这些中间 CA 又可以去认证其他的中间 CA。</p><p>因此，每个根 CA 机构都维护了一个树状结构，一个根 CA 下面包含多个中间 CA，而中间 CA 又可以包含多个中间 CA。这样就形成了一个证书链，你可以沿着证书链从用户证书追溯到根证书。</p><p><img src="'+r+'" alt="图 3"></p><p><strong>根证书的 CA 机构作为最后的信任源！</strong></p><p>首先操作系统和浏览器都内置了各大 CA 的根证书。浏览器会对服务器返回的是证书链（不包括根证书，根证书预置在浏览器中）查找到根证书，然后逐级使用上一级证书的公钥对下一级证书进行摘要验签。</p><p><img src="'+i+'" alt="图 6"></p><p><img src="'+t+'" alt="图 7"></p><p>浏览器怎么证明根证书是合法的？其实浏览器的判断策略很简单，它只是简单地判断这个根证书在不在操作系统里面，如果在，那么浏览器就认为这个根证书是合法的，如果不在，那么就是非法的。</p><p>从上流程分析可知，如果证书链的最后一端如果遭到恶意攻击，那么 https 并非是绝对安全的。</p><h3 id="https-安全原理总结" tabindex="-1"><a class="header-anchor" href="#https-安全原理总结" aria-hidden="true">#</a> https 安全原理总结</h3><p>SSL/TLS 为 http 增加了安全特性具体体现：</p><ul><li>数据传输安全 <ul><li>保密性：靠混合加密解决，非对称加密实现对称加密秘钥传递，对称加密实现内容加密</li><li>完整性：靠摘要算法解决</li></ul></li><li>通过数字证书和 CA 机构组成的证书链，确保浏览器对服务器的信任问题 <ul><li>数字签名是用私钥对证书的摘要进行加密，可以由公钥解密后进行摘要验证，实现身份认证和不可否认</li></ul></li></ul><h2 id="tls-连接" tabindex="-1"><a class="header-anchor" href="#tls-连接" aria-hidden="true">#</a> TLS 连接</h2><h3 id="rsa-握手" tabindex="-1"><a class="header-anchor" href="#rsa-握手" aria-hidden="true">#</a> RSA 握手</h3><p><img src="'+o+'" alt="图 19"></p><ol><li>客户端发一个“Client Hello”消息，里面有本地 TLS 版本号、支持的密码套件列表，还有一个客户端随机数（Client Random）</li><li>服务器收到消息后，会确认 TLS 版本，从密码套件列表选择一个密码套件，并生成一个服务端随机数（Server Random），然后返回一个“Server Hello”消息告诉客户端，随后并将自己的证书发送给客户端，然后结束</li><li>客户端会进行证书验证，验证通过后，生成 pre-master 随机数，然后用公钥加密传给服务器</li><li>服务端使用自己的私钥进行解密，使用 pre-master 随机数、客户端随机数（Client Random）、服务端随机数（Server Random）算出 master secret 会话密钥，客户端也是同样做法</li><li>客户端告诉服务器我之后都使用加密进行通信了，结束；服务端也告诉客户端，我也要开始使用加密通信了，over</li><li>之后双方使用 master secret进行消息加密</li></ol><h3 id="ecdhe-握手过程" tabindex="-1"><a class="header-anchor" href="#ecdhe-握手过程" aria-hidden="true">#</a> ECDHE 握手过程</h3><p><img src="'+c+'" alt="图 18"></p><p><img src="'+h+'" alt="图 17"></p><ol><li>客户端发一个“Client Hello”消息，里面有本地 TLS 版本号、支持的密码套件列表，还有一个客户端随机数（Client Random）</li><li>服务器收到消息后，会确认 TLS 版本，从密码套件列表选择一个密码套件，并生成一个服务端随机数（Server Random），然后发送一个“Server Hello”消息告诉客户端，并将自己的证书发送给客户端</li><li>服务器发送 “Server Key Exchange” 消息，里面主要是 ECDHE 算法的服务端参数（Server Params），然后发送结束</li><li>客户端证书验证通过后，则发送 “Client Key Exchange” 消息，里面是 ECDHE 算法的客户端参数（Client Params）</li><li>客户端和服务器可以根据 Client Params、Server Params 用 ECDHE 算法计算出 Pre-Master 随机数，然后使用 Client Random、Server Random 和 Pre-Master 生成会话密钥的主密 Master Secret</li></ol><h2 id="tls-1-3" tabindex="-1"><a class="header-anchor" href="#tls-1-3" aria-hidden="true">#</a> TLS/1.3</h2><p>TLS/1.3 新增内容：</p><ul><li>扩展协议</li><li>强化安全、简化密码套件</li><li>提升性能：1-RTT 握手</li></ul><h3 id="扩展协议" tabindex="-1"><a class="header-anchor" href="#扩展协议" aria-hidden="true">#</a> 扩展协议</h3><p>由于 1.1、1.2 等协议已经出现了很多年，很多应用软件、中间代理（官方称为“MiddleBox”）只认老的记录协议格式，更新改造很困难，甚至有些只认记录头的 Version 字段仅为 1.2。为了保证兼容旧版本而扩展支持 1.3，新增了扩展协议：</p><div class="language-text ext-text"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292f;">Handshake Protocol: Client Hello</span></span>\n<span class="line"><span style="color:#24292f;">    Version: TLS 1.2 (0x0303)</span></span>\n<span class="line"><span style="color:#24292f;">    Extension: supported_versions (len=11)</span></span>\n<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.3 (0x0304)</span></span>\n<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.2 (0x0303)</span></span>\n<span class="line"><span style="color:#24292f;"></span></span></code></pre></div><p>只要是 TLS1.3 协议，握手的“Hello”消息后面就必须有“supported_versions”扩展，它除了标记了 TLS 的版本号，还支持等其他 1.3 许多重要的功能。使用它就能区分新旧协议，旧服务器不支持 supported_versions 就会忽略，这样自动“后向兼容”降级成了 1.2。</p><h3 id="强化安全、简化密码套件" tabindex="-1"><a class="header-anchor" href="#强化安全、简化密码套件" aria-hidden="true">#</a> 强化安全、简化密码套件</h3><p>TLS1.3 废除了很多有漏洞、加密弱的加密算法，这样简化了密码套件列表：</p><p><img src="'+d+'" alt="图 20"></p><p>其中最主要废除 RSA 和 DH 密钥交换算法，只保留了 ECDHE 和 DHE。RSA 和 DH 主要不具备“向前安全”性：服务器私钥参与密钥交换算法过程，一旦私钥泄露或被破解，那么黑客就能够使用私钥解密出之前所有报文的“Pre-Master”，再算出会话密钥，破解所有密文；而 ECDHE、DHE 算法在每次握手时都会生成一对临时的公钥和私钥，每次通信的密钥对都是不同的。</p><h3 id="提升性能-1-rtt-握手" tabindex="-1"><a class="header-anchor" href="#提升性能-1-rtt-握手" aria-hidden="true">#</a> 提升性能：1-RTT 握手</h3><p>TLS1.2 握手过程需要 2-RTT 才能完成握手，TLS1.3 压缩了以前的“Hello”协商过程，删除了“Key Exchange”消息，把握手时间减少到了“1-RTT”，效率提高了一倍。</p><p><img src="'+u+'" alt="图 21"></p><p>客户端在“Client Hello”消息里直接用“supported_groups”带上支持的曲线，比如 P-256、x25519，用“key_share”带上曲线对应的客户端公钥参数，用“signature_algorithms”带上签名算法。</p><div class="language-text ext-text"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292f;">Handshake Protocol: Client Hello</span></span>\n<span class="line"><span style="color:#24292f;">    Version: TLS 1.2 (0x0303)</span></span>\n<span class="line"><span style="color:#24292f;">    Random: cebeb6c05403654d66c2329…</span></span>\n<span class="line"><span style="color:#24292f;">    Cipher Suites (18 suites)</span></span>\n<span class="line"><span style="color:#24292f;">        Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)</span></span>\n<span class="line"><span style="color:#24292f;">        Cipher Suite: TLS_CHACHA20_POLY1305_SHA256 (0x1303)</span></span>\n<span class="line"><span style="color:#24292f;">        Cipher Suite: TLS_AES_256_GCM_SHA384 (0x1302)</span></span>\n<span class="line"><span style="color:#24292f;">    Extension: supported_versions (len=9)</span></span>\n<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.3 (0x0304)</span></span>\n<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.2 (0x0303)</span></span>\n<span class="line"><span style="color:#24292f;">    Extension: supported_groups (len=14)</span></span>\n<span class="line"><span style="color:#24292f;">        Supported Groups (6 groups)</span></span>\n<span class="line"><span style="color:#24292f;">            Supported Group: x25519 (0x001d)</span></span>\n<span class="line"><span style="color:#24292f;">            Supported Group: secp256r1 (0x0017)</span></span>\n<span class="line"><span style="color:#24292f;">    Extension: key_share (len=107)</span></span>\n<span class="line"><span style="color:#24292f;">        Key Share extension</span></span>\n<span class="line"><span style="color:#24292f;">            Client Key Share Length: 105</span></span>\n<span class="line"><span style="color:#24292f;">            Key Share Entry: Group: x25519</span></span>\n<span class="line"><span style="color:#24292f;">            Key Share Entry: Group: secp256r1</span></span>\n<span class="line"><span style="color:#24292f;"></span></span></code></pre></div><p>服务端还是要给出一个随机数（Server Random）和选定密码套件，最主要在“supported_versions”里确认使用的是 TLS1.3，然后在“key_share”扩展带上曲线和对应的公钥参数。</p><div class="language-text ext-text"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292f;">Handshake Protocol: Server Hello</span></span>\n<span class="line"><span style="color:#24292f;">    Version: TLS 1.2 (0x0303)</span></span>\n<span class="line"><span style="color:#24292f;">    Random: 12d2bce6568b063d3dee2…</span></span>\n<span class="line"><span style="color:#24292f;">    Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)</span></span>\n<span class="line"><span style="color:#24292f;">    Extension: supported_versions (len=2)</span></span>\n<span class="line"><span style="color:#24292f;">        Supported Version: TLS 1.3 (0x0304)</span></span>\n<span class="line"><span style="color:#24292f;">    Extension: key_share (len=36)</span></span>\n<span class="line"><span style="color:#24292f;">        Key Share extension</span></span>\n<span class="line"><span style="color:#24292f;">            Key Share Entry: Group: x25519, Key Exchange length: 32</span></span>\n<span class="line"><span style="color:#24292f;"></span></span></code></pre></div><h2 id="学习参考" tabindex="-1"><a class="header-anchor" href="#学习参考" aria-hidden="true">#</a> 学习参考</h2>',83),f={href:"https://zhuanlan.zhihu.com/p/43789231",target:"_blank",rel:"noopener noreferrer"},g=(0,a.Uk)("彻底搞懂HTTPS的加密原理"),_=(0,a._)("li",null,[(0,a._)("p",null,"《透视 HTTP 协议》")],-1),C=(0,a._)("li",null,[(0,a._)("p",null,"《浏览器工作原理与实践》")],-1),T={href:"https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity",target:"_blank",rel:"noopener noreferrer"},y=(0,a.Uk)("SSL Certificate framework 101: How does the browser actually verify the validity of a given server certificate?"),m=(0,a._)("li",null,[(0,a._)("p",null,"原理"),(0,a._)("ul",null,[(0,a._)("li",null,"混合加密：使用非对称加密传输对称加密密钥"),(0,a._)("li",null,"数字证书（包含公钥）"),(0,a._)("li",null,"数字签名及验证：私钥加密，证书公钥解密；")])],-1),x=(0,a._)("p",null,"ECDHE中，没有采用服务器公钥来加密数据，而是采用交换两端的椭圆曲线公钥来保证pre_master的安全性 RSA中pre_master由客户端生成，采用服务器公钥加密pre_master来保证pre_master的安全性",-1),b=(0,a._)("p",null,"然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。 对称加密的私钥又是会话级的随机数=一次会话一个私钥。就算别人baoli破解也只是破解了一个会话（TCP 长连接期间）。",-1),v=(0,a._)("p",null,"对称加密：AES_128/256 非：RSA，rsa一般要2048位",-1),A=(0,a._)("ul",null,[(0,a._)("li",null,"现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”，“PRF”就是伪随机数函数，它基于密码套件里的最后一个参数，比如这次的 SHA384，通过摘要算法来再一次强化“Master Secret”的随机性。"),(0,a._)("li",null,"客户端发一个“Change Cipher Spec”"),(0,a._)("li",null,"然后再发一个“Finished”消息"),(0,a._)("li",null,"服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。")],-1),E=(0,a._)("p",null,"主密钥有 48 字节，但它也不是最终用于通信的会话密钥，还会再用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患",-1),L=(0,a._)("p",null,"ECDHE 算法",-1),H={},k=(0,l(3860).Z)(H,[["render",function(e,s){const l=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)("div",null,[S,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("p",null,[(0,a._)("a",f,[g,(0,a.Wm)(l)])])]),_,C,(0,a._)("li",null,[(0,a._)("p",null,[(0,a._)("a",T,[y,(0,a.Wm)(l)])])]),m]),x,b,v,A,E,L])}]])},3860:(e,s)=>{s.Z=(e,s)=>{const l=e.__vccOpts||e;for(const[e,a]of s)l[e]=a;return l}}}]);