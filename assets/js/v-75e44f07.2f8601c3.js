"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[4725],{474:(e,l,a)=>{a.r(l),a.d(l,{data:()=>i});const i={key:"v-75e44f07",path:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8AHTTP/TCP%20&%20UDP.html",title:"TCP & UDP",lang:"zh-CN",frontmatter:{release:!0,tags:["tcp","http"]},excerpt:"",headers:[{level:2,title:"TCP",slug:"tcp",children:[{level:3,title:"TCP 封包结构",slug:"tcp-封包结构",children:[]},{level:3,title:"TCP 可靠性",slug:"tcp-可靠性",children:[]},{level:3,title:"三次握手：建立连接的过程",slug:"三次握手-建立连接的过程",children:[]},{level:3,title:"你可能以为 2 次握手就足够了，为什么需要第三次握手？",slug:"你可能以为-2-次握手就足够了-为什么需要第三次握手",children:[]},{level:3,title:"四次挥手：断开连接",slug:"四次挥手-断开连接",children:[]},{level:3,title:"为什么四次挥手",slug:"为什么四次挥手",children:[]}]},{level:2,title:"UDP",slug:"udp",children:[{level:3,title:"UDP 的封包格式",slug:"udp-的封包格式",children:[]}]},{level:2,title:"参考",slug:"参考",children:[]}],git:{createdTime:1664433214e3,updatedTime:1664433214e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:1}]}}},8793:(e,l,a)=>{a.r(l),a.d(l,{default:()=>p});var i=a(5393);const t=a.p+"assets/img/1650461401083.e226ecc7.png",r=a.p+"assets/img/1650463890877.b25ea678.png",n=a.p+"assets/img/1650463449940.f9ca7765.png",h=a.p+"assets/img/1661276831295.48dc8023.png",d=(0,i.uE)('<h1 id="tcp-udp" tabindex="-1"><a class="header-anchor" href="#tcp-udp" aria-hidden="true">#</a> TCP &amp; UDP</h1><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><p>TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。</p><h3 id="tcp-封包结构" tabindex="-1"><a class="header-anchor" href="#tcp-封包结构" aria-hidden="true">#</a> TCP 封包结构</h3><p><img src="'+t+'" alt="图 8"></p><ul><li>序号(seq)：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。<br> 例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。</li><li>确认号(ack)：期望收到对方下一个报文段的第一个数据字节的序号，ack = 已接受序号 + 1</li><li>标识符 <ul><li>SYN：请求连接</li><li>FIN：连接终止</li><li>ACK：表示发来的数据已确认接收无误</li><li>PSH：数据推送</li><li>RST</li><li>URG</li></ul></li></ul><h3 id="tcp-可靠性" tabindex="-1"><a class="header-anchor" href="#tcp-可靠性" aria-hidden="true">#</a> TCP 可靠性</h3><p>TCP</p><ul><li>拆包、粘包</li><li>ACK：请求-应答模式，无论哪一方收到数据后，都需要给发送方一个 ACK 响应</li><li>状态记录：记录发送包、接受包， <ul><li>有时间窗口持续收集无序的数据，直到这一批数据都可以合理地排序组成连续的结果。</li><li>TCP 会有握手的过程，需要建立连接，保证双方同时在线</li></ul></li><li>流控制 <ul><li>TCP 使用了流控技术来确保发送方不会因为一次发送过多的数据包而使接收方不堪重负。TCP 在发送缓冲区中存储数据，并在接收缓冲区中接收数据</li></ul></li></ul><h3 id="三次握手-建立连接的过程" tabindex="-1"><a class="header-anchor" href="#三次握手-建立连接的过程" aria-hidden="true">#</a> 三次握手：建立连接的过程</h3><p>TCP 是一个面向连接的协议，也就是通信前需要建立连接。</p><p>连接是通信双方的一个约定，目标是让两个在通信的程序之间产生一个默契，保证两个程序都在线，而且尽快地响应对方的请求，这就是连接（Connection）。<strong>连接是网络行为状态的记录</strong>。在传输之前，建立一个连接。具体来说，数据收发双方的内存中都建立一个用于维护数据传输状态的对象，如ip地址、端口号等。</p><p>三次握手就是为了确认双方的接收能力和发送能力是否正常，初始状态：指定自己的 初始化序列号(Init Sequense Number, ISN) 为后面的可靠性传输做准备。</p><p><img src="'+r+'" alt="图 10"></p><h3 id="你可能以为-2-次握手就足够了-为什么需要第三次握手" tabindex="-1"><a class="header-anchor" href="#你可能以为-2-次握手就足够了-为什么需要第三次握手" aria-hidden="true">#</a> 你可能以为 2 次握手就足够了，为什么需要第三次握手？</h3><p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)建立状态，以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><blockquote><p>ISN (Initial Sequence Number) 不可以是固定，当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p></blockquote><ul><li>建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）去交互初始序号</li><li>由于 TCP 可靠性基于请求-应答模式，无论哪一方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。</li><li>而且握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复</li></ul><h3 id="四次挥手-断开连接" tabindex="-1"><a class="header-anchor" href="#四次挥手-断开连接" aria-hidden="true">#</a> 四次挥手：断开连接</h3><p><img src="'+n+'" alt="图 9"></p><p>其中第四次挥手后，客户端需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 CLOSED 状态（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。</p><h3 id="为什么四次挥手" tabindex="-1"><a class="header-anchor" href="#为什么四次挥手" aria-hidden="true">#</a> 为什么四次挥手</h3><ol><li>当你收到 FIN 报文时，基于可靠性要求，无论是哪方收到消息后，都需要给发送方一个 ACK（Acknowledgement）响应。如果一个请求没有响应，发送方可能会认为自己需要重发这个请求</li><li>因为 TCP 是全双工通信的，当你收到 FIN 报文仅仅意味着对方不会再发送数据，但是可以继续接受数据，当你也发送 FIN 报文时才意味着连接可以断开</li><li>断开连接需要资源释放处理，因此断开连接不能像握手那样操作将两条消息合并发送</li></ol><h2 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h2><p>UDP（User Datagram Protocol）是面向用户数据报文的协议，目标是在传输层提供直接发送报文（Datagram）的能力。Datagram 是数据传输的最小单位。UDP 协议不会帮助拆分数据，它的目标只有一个，就是发送报文。</p><h3 id="udp-的封包格式" tabindex="-1"><a class="header-anchor" href="#udp-的封包格式" aria-hidden="true">#</a> UDP 的封包格式</h3><p><img src="'+h+'" alt="图 6"></p><ul><li>Checksum 是校验和，作用是检查封包是否出错。如果一个数据封包 Datagram 发生了数据损坏，UDP 可以通过 Checksum 纠错或者修复。</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',29),c={href:"https://segmentfault.com/a/1190000039165592",target:"_blank",rel:"noopener noreferrer"},s=(0,i.Uk)("关于 TCP 三次握手和四次挥手，满分回答在此"),u={},p=(0,a(3860).Z)(u,[["render",function(e,l){const a=(0,i.up)("ExternalLinkIcon");return(0,i.wg)(),(0,i.iD)("div",null,[d,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i._)("a",c,[s,(0,i.Wm)(a)])])])])}]])},3860:(e,l)=>{l.Z=(e,l)=>{const a=e.__vccOpts||e;for(const[e,i]of l)a[e]=i;return a}}}]);