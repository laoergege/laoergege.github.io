"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[7126],{7421:(l,i,e)=>{e.r(i),e.d(i,{data:()=>u});const u={key:"v-137d7552",path:"/Rust/",title:"Rust",lang:"zh-CN",frontmatter:{release:!0,tags:["rust"]},excerpt:"",headers:[{level:2,title:"rust 程序骨架",slug:"rust-程序骨架",children:[]},{level:2,title:"cargo：包管理工具",slug:"cargo-包管理工具",children:[{level:3,title:"cargo workspace",slug:"cargo-workspace",children:[]}]}],git:{createdTime:1630400773e3,updatedTime:1665411796e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:19}]}}},3629:(l,i,e)=>{e.r(i),e.d(i,{default:()=>X});var u=e(5393);const r=(0,u._)("h1",{id:"rust",tabindex:"-1"},[(0,u._)("a",{class:"header-anchor",href:"#rust","aria-hidden":"true"},"#"),(0,u.Uk)(" Rust")],-1),n=(0,u.Uk)("Rust "),a=(0,u._)("li",null,[(0,u.Uk)("设计理念 "),(0,u._)("ul",null,[(0,u._)("li",null,"性能、内存安全、并发安全"),(0,u._)("li",null,"划分 Safe rust 和 Unsafe Rust（方便与其他语言沟通）"),(0,u._)("li",null,"多范式编程")])],-1),t=(0,u.Uk)("语法特性 "),o=(0,u.Uk)("内存安全：所有权、借用及生命周期"),s=(0,u._)("li",null,[(0,u.Uk)("面向表达式 "),(0,u._)("ul",null,[(0,u._)("li",null,[(0,u.Uk)("一切皆是表达式，即一切皆类型（表达式会产生值，值即类型，rust 就是通过一切类型检查保证内存安全、并发安全） "),(0,u._)("ul",null,[(0,u._)("li",null,"控制流语句"),(0,u._)("li",null,"函数")])]),(0,u._)("li",null,"编译期计算")])],-1),c=(0,u.Uk)("编程基础 "),d=(0,u._)("li",null,"变量、值和类型",-1),_=(0,u._)("li",null,"表达式与运算符",-1),h=(0,u.Uk)("控制流 "),p=(0,u._)("li",null,"顺序",-1),g=(0,u._)("li",null,"调用",-1),k=(0,u._)("li",null,[(0,u.Uk)("循环："),(0,u._)("code",null,"loop / while(条件) / for...in(迭代器)"),(0,u.Uk)(" + "),(0,u._)("code",null,"break / continue / return")],-1),f=(0,u.Uk)("跳转 "),m=(0,u._)("li",null,[(0,u.Uk)("分支跳转 "),(0,u._)("code",null,"if ... else ...")],-1),b=(0,u._)("li",null,[(0,u.Uk)("模式匹配 "),(0,u._)("ul",null,[(0,u._)("li",null,[(0,u._)("code",null,"match expr {}")]),(0,u._)("li",null,[(0,u._)("code",null,"if let / while let")])])],-1),E=(0,u.Uk)("错误处理"),U=(0,u._)("li",null,"异步跳转",-1),w=(0,u.uE)("<li>函数 <code>fn</code></li><li>模块系统：箱、模块、路径 <ul><li>箱 crate：一个项目也被称为一个 crate，crate 可以是可执行项目，也可以是一个库</li><li>模块 <code>mod</code>：模块是一个箱内的代码组织单位，在 Rust 中声明模块的方式有两种：内联或在其他文件中声明</li><li><code>pub</code>：导出</li><li><code>use</code>：导入</li></ul></li><li>数据结构 <ul><li>数组</li><li>矢量 <code>Vec</code></li><li>哈希 <code>HashMap</code></li></ul></li><li>测试 <ul><li>单元测试 <ul><li><code>#[test]</code></li><li><code>#[should_panic]</code> 预期的失败</li><li><code>#[ignore]</code> 忽略测试</li></ul></li><li>文档测试 <code>///</code></li><li>集成测试</li></ul></li>",4),y=(0,u.uE)('<li>进阶 <ul><li>类型系统 <ul><li>类型是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息；值是无法脱离具体的类型讨论的</li><li>内存分配 <ul><li>准则：栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期</li></ul></li><li>分类 <ul><li>原生类型</li><li>组合类型/复合类型 <ul><li>结构体（struct）：多个类型组合在一起共同表达一个值的复杂数据结构 <ul><li>经典结构体</li><li>元组</li><li>单元结构</li></ul></li><li>枚举（enum）：联合标签</li></ul></li></ul></li><li>指针和引用 <ul><li>指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到任意数据类型，但如果没有用正确的类型解引用一个指针，那么会引发各种各样的内存问题</li><li>引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用</li><li>引用的实现上比正常指针携带更多信息的指针，我们称之为胖指针（fat pointer），很多数据结构的引用，内部都是由胖指针实现的</li></ul></li></ul></li><li>泛型 <ul><li>数据结构的泛型</li><li>使用泛型结构代码的泛型化</li></ul></li><li>面向接口编程 <ul><li>接口将调用者和实现者隔离开，大大促进了代码的复用和扩展。面向接口编程可以让系统变得灵活，但是当使用接口去引用具体的类型时，在运行时变量原本的类型被抹去，我们无法单纯从一个指针分析出这个引用具备什么样的能力，所以我们就需要虚表来辅助运行时代码的执行。有了虚表，我们可以很方便地进行动态分派，它是运行时多态的基础。</li><li>Trait</li></ul></li><li>函数式编程 <ul><li>函数往往是一等公民</li><li>闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。</li></ul></li><li>并发编程 <ul><li>并发是系统拥有同时与多件事情打交道的能力；并行是同时处理多件事情的手段 <img src="images/1653375009755.png" alt="图 17"></li><li>异步编程</li></ul></li><li>宏编程 <ul><li>声明宏</li><li>过程宏 <ul><li>函数宏</li><li>派生宏</li><li>属性宏</li></ul></li></ul></li><li>面向对象编程</li></ul></li><li>实现 <ul><li>基于 LLVM，具有可移植性</li></ul></li><li>工程化 <ul><li>工具链 <ul><li>rustup：工具链管理工具 <ul><li>rust-toolchain.toml</li></ul></li><li>rustc：rust 编译器 <ul><li>支持类型推导，使得写代码时的直观感受和写脚本语言差不多👍</li></ul></li><li><a href="#cargo%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7">cargo：包管理工具</a></li></ul></li></ul></li><li>生态 <ul><li>WSAI</li></ul></li>',4),A=(0,u.Uk)("资料 "),R=(0,u.Uk)("[x] "),F={href:"https://docs.microsoft.com/zh-cn/learn/paths/rust-first-steps/",target:"_blank",rel:"noopener noreferrer"},W=(0,u.Uk)("Microsoft Rust 教程"),x=(0,u.Uk)("[ ] "),v={href:"https://kaisery.github.io/trpl-zh-cn/title-page.html",target:"_blank",rel:"noopener noreferrer"},C=(0,u.Uk)("Rust 程序设计语言"),z=(0,u.Uk)("[ ] "),B={href:"https://course.rs/about-book.html",target:"_blank",rel:"noopener noreferrer"},D=(0,u.Uk)("Rust语言圣经(Rust Course)"),L=(0,u.Uk)("[ ] "),M={href:"https://github.com/tyrchen/rust-training",target:"_blank",rel:"noopener noreferrer"},T=(0,u.Uk)("rust-training"),I=(0,u.Uk)("[ ] "),S={href:"https://github.com/ctjhoa/rust-learning",target:"_blank",rel:"noopener noreferrer"},V=(0,u.Uk)("rust-learning"),Z=(0,u.Uk)("[ ] "),j={href:"https://github.com/rust-unofficial/awesome-rust",target:"_blank",rel:"noopener noreferrer"},H=(0,u.Uk)("awesome-rust"),N=(0,u.Uk)("[ ] "),O={href:"https://rust-lang.github.io/async-book/03_async_await/01_chapter.html",target:"_blank",rel:"noopener noreferrer"},P=(0,u.Uk)(" Asynchronous Programming in Rust"),q=(0,u.uE)('<h2 id="rust-程序骨架" tabindex="-1"><a class="header-anchor" href="#rust-程序骨架" aria-hidden="true">#</a> rust 程序骨架</h2><ul><li>分割符 <ul><li>属性，<code>#![...]</code></li><li>分号，<code>;</code>，行分隔符</li><li>花括号，<code>{}</code>，块分隔符</li></ul></li><li>表达式和语句 <ul><li>表达式：计算求值</li><li>语句：操作</li><li>程序：语句集合</li><li>语句 <ul><li>声明语句</li><li>表达式语句</li></ul></li></ul></li><li>面向表达式 <ul><li>分号也是一种表达式，<code>; -&gt; ()</code>，返回单元类型，平常只做分隔符，在块最后可做表达式</li><li>块表达式会对最后表达式求值并返回</li></ul></li></ul><h2 id="cargo-包管理工具" tabindex="-1"><a class="header-anchor" href="#cargo-包管理工具" aria-hidden="true">#</a> cargo：包管理工具</h2><ul><li>cargo <ul><li>概念 <ul><li>workspace：多项目组织</li></ul></li><li>配置：Cargo.toml</li><li>命令 <ul><li>cargo new --bin/lib</li><li>cargo build [--release]</li><li>cargo test</li></ul></li></ul></li></ul><h3 id="cargo-workspace" tabindex="-1"><a class="header-anchor" href="#cargo-workspace" aria-hidden="true">#</a> cargo workspace</h3>',5),G={href:"https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html",target:"_blank",rel:"noopener noreferrer"},J=(0,u.Uk)("cargo workspaces"),K=(0,u.uE)('<div class="language-toml ext-toml"><pre class="shiki" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[</span><span style="color:#953800;">workspace</span><span style="color:#24292F;">]</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#24292F;">members = [</span></span>\n<span class="line"><span style="color:#24292F;">    </span><span style="color:#82071E;font-style:italic;">...</span></span>\n<span class="line"><span style="color:#24292F;">]</span></span>\n<span class="line"></span></code></pre></div>',1),Q={},X=(0,e(3860).Z)(Q,[["render",function(l,i){const e=(0,u.up)("RouterLink"),Q=(0,u.up)("ExternalLinkIcon");return(0,u.wg)(),(0,u.iD)("div",null,[r,(0,u._)("ul",null,[(0,u._)("li",null,[n,(0,u._)("ul",null,[a,(0,u._)("li",null,[t,(0,u._)("ul",null,[(0,u._)("li",null,[(0,u.Wm)(e,{to:"/Rust/%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%EF%BC%9A%E6%89%80%E6%9C%89%E6%9D%83%E3%80%81%E5%80%9F%E7%94%A8%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"},{default:(0,u.w5)((()=>[o])),_:1})]),s])]),(0,u._)("li",null,[c,(0,u._)("ul",null,[d,_,(0,u._)("li",null,[h,(0,u._)("ul",null,[p,g,k,(0,u._)("li",null,[f,(0,u._)("ul",null,[m,b,(0,u._)("li",null,[(0,u.Wm)(e,{to:"/Rust/Rust%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html"},{default:(0,u.w5)((()=>[E])),_:1})]),U])])])]),w])]),y,(0,u._)("li",null,[A,(0,u._)("ul",null,[(0,u._)("li",null,[R,(0,u._)("a",F,[W,(0,u.Wm)(Q)])]),(0,u._)("li",null,[x,(0,u._)("a",v,[C,(0,u.Wm)(Q)])]),(0,u._)("li",null,[z,(0,u._)("a",B,[D,(0,u.Wm)(Q)])]),(0,u._)("li",null,[L,(0,u._)("a",M,[T,(0,u.Wm)(Q)])]),(0,u._)("li",null,[I,(0,u._)("a",S,[V,(0,u.Wm)(Q)])]),(0,u._)("li",null,[Z,(0,u._)("a",j,[H,(0,u.Wm)(Q)])]),(0,u._)("li",null,[N,(0,u._)("a",O,[P,(0,u.Wm)(Q)])])])])])])]),q,(0,u._)("p",null,[(0,u._)("a",G,[J,(0,u.Wm)(Q)])]),K])}]])},3860:(l,i)=>{i.Z=(l,i)=>{const e=l.__vccOpts||l;for(const[l,u]of i)e[l]=u;return e}}}]);