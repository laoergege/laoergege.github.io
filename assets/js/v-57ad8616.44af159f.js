"use strict";(self.webpackChunklaoergege_blog=self.webpackChunklaoergege_blog||[]).push([[1736],{351:(e,a,l)=>{l.r(a),l.d(a,{data:()=>i});const i={key:"v-57ad8616",path:"/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AWebAPI/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.html",title:"浏览器页面渲染原理",lang:"zh-CN",frontmatter:{release:!0,tags:["页面渲染","chrome"],desc:"了解 Chrome 页面是如何渲染？"},excerpt:"",headers:[{level:2,title:"渲染管道",slug:"渲染管道",children:[]},{level:2,title:"渲染流程",slug:"渲染流程",children:[{level:3,title:"Parse HTML：构建 DOM 树",slug:"parse-html-构建-dom-树",children:[]},{level:3,title:"Recalculate Style：样式计算",slug:"recalculate-style-样式计算",children:[]},{level:3,title:"Layout：布局计算",slug:"layout-布局计算",children:[]},{level:3,title:"分层（Layers）",slug:"分层-layers",children:[]},{level:3,title:"Paint：绘制",slug:"paint-绘制",children:[]},{level:3,title:"Raster（栅格化）",slug:"raster-栅格化",children:[]},{level:3,title:"显示器显示图像原理",slug:"显示器显示图像原理",children:[]}]}],git:{createdTime:1664724638e3,updatedTime:1664724638e3,contributors:[{name:"连远生",email:"lianyuansheng@xiao100.com",commits:1}]}}},4489:(e,a,l)=>{l.r(a),l.d(a,{default:()=>T});var i=l(5393);const r=l.p+"assets/img/stages.a2a44174.png",t=l.p+"assets/img/openGL.ce2bf6fb.png",s=l.p+"assets/img/1652279790369.0e4da626.png",n=l.p+"assets/img/1652279853178.1e3d5507.png",p=l.p+"assets/img/微信截图_20200606211336.bc98e4f7.png",o=l.p+"assets/img/e2c917edf5119cddfbec9481372f8fc0.28bdb6a2.png",c=l.p+"assets/img/tree.b257643b.png",h=l.p+"assets/img/a03eb12053aac1ac496b61a424f20119.bd608ef3.png",d=l.p+"assets/img/微信截图_20200607154033.76fef964.png",u=l.p+"assets/img/303515c26fcd4eaa9b9966ad7f190370.2f0d58ef.png",g=l.p+"assets/img/paint-phases.50cea9f9.png",m=(0,i._)("h1",{id:"浏览器页面渲染原理",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#浏览器页面渲染原理","aria-hidden":"true"},"#"),(0,i.Uk)(" 浏览器页面渲染原理")],-1),f=(0,i._)("blockquote",null,[(0,i._)("p",null,"以 Chrome 浏览器为例理解现代化浏览器渲染原理")],-1),b=(0,i.Uk)("现代化浏览器多进程架构中，浏览器会进程创建一个沙箱的渲染进程，并使用 Web 渲染引擎（如 "),y={href:"https://www.chromium.org/blink",target:"_blank",rel:"noopener noreferrer"},k=(0,i.Uk)("Blink"),_=(0,i.Uk)("）将 HTML、CSS 和 JavaScript 等 Web 内容转换为用户可以与之交互的网页。"),v=(0,i.uE)('<p>渲染进程包含：</p><ul><li>主线程（Blink 渲染引擎）</li><li>合成线程 compositor (&quot;cc&quot;)</li><li>worker 线程</li><li>光栅线程</li></ul><h2 id="渲染管道" tabindex="-1"><a class="header-anchor" href="#渲染管道" aria-hidden="true">#</a> 渲染管道</h2><p>一个页面形成需要经过多个流程阶段，我们把这样的一个处理流程叫做渲染流水线或者渲染管道。</p><p><img src="'+r+'" alt=""></p><p>渲染是一个复杂的过程，为了提高渲染效率，整个渲染渲染流程就像是一条管道，分成多个渲染阶段，每个阶段都会产生中间产物，当发生更新时，就可以从某一阶段的产物复用开始，这样即提高渲染效率并且分多阶段任务执行，可以降低系统复杂度，提高任务调度灵活性。</p><p><strong>管道的最终是将 content 转换成底层操作系统提供的图形库调用操作，去驱动显卡生成页面像素</strong>，在多平台的今天，有标准 API 图形库 OpenGL，但在 window 平台，还需要额外转换成 DirectX API 调用，未来还将实现更多图形库支持，如 vulkan。</p><p><img src="'+t+'" alt=""></p><h2 id="渲染流程" tabindex="-1"><a class="header-anchor" href="#渲染流程" aria-hidden="true">#</a> 渲染流程</h2><h3 id="parse-html-构建-dom-树" tabindex="-1"><a class="header-anchor" href="#parse-html-构建-dom-树" aria-hidden="true">#</a> Parse HTML：构建 DOM 树</h3><p>将 HTML 解析成一种树形数据结构 DOM（Document Object Model）。</p><p><img src="'+s+'" alt="图 15"></p><h3 id="recalculate-style-样式计算" tabindex="-1"><a class="header-anchor" href="#recalculate-style-样式计算" aria-hidden="true">#</a> Recalculate Style：样式计算</h3><ol><li>CSS 解析，同 HTML 解析一样，将 CSS 文本解析成内部数据结构 styleSheets</li><li>计算出 DOM 树中每个节点的具体样式，并被保存在 ComputedStyle 的结构内，在计算过程中需要遵守 CSS 的<strong>继承和层叠</strong>两个规则。</li></ol><p><img src="'+n+'" alt="图 16"></p><h3 id="layout-布局计算" tabindex="-1"><a class="header-anchor" href="#layout-布局计算" aria-hidden="true">#</a> Layout：布局计算</h3><ol><li><p>创建布局树（Layout Tree），遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中。</p><p><img src="'+p+'" alt=""></p><p>DOM 并不是跟 layout tree 的节点并不是一对一对应关系，不可见的节点包括：</p><ul><li>display：none 的元素</li><li>伪元素 after 与 before</li><li>文本内联元素将会被隐式 block 包裹</li><li>head 标签下面的全部内容等</li></ul></li><li><p>布局计算，计算每个节点的布局信息，比如坐标及几何等信息。</p></li></ol><h3 id="分层-layers" tabindex="-1"><a class="header-anchor" href="#分层-layers" aria-hidden="true">#</a> 分层（Layers）</h3><p>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</p><p><img src="'+o+'" alt="Chrome Devtool Layers 标签，可视化页面分层"></p><p>如果没有采用分层机制，那么每次页面有很小的变化时，都从布局树直接生成目标图片的话，会严重影响页面的渲染效率。</p><p>为了提升每帧的渲染效率，Chrome 引入了<strong>分层和合成</strong>的机制。</p><p><img src="'+c+'" alt=""></p><p>上图中从 DOM 到最终 Graphic Layer（图层）的转换并不是一对一，只有具有特定样式的节点会被转换为单独的图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层，比如 <code>span</code> 节点还是属于 <code>div</code> 图层。</p><h4 id="paintlayers-渲染层" tabindex="-1"><a class="header-anchor" href="#paintlayers-渲染层" aria-hidden="true">#</a> PaintLayers（渲染层）</h4><p>PaintLayer 是用来实现 stacking contest（层叠上下文），以此来保证页面元素以正确的显示顺序，这样才能正确的展示元素的重叠以及半透明元素等等</p><p><img src="'+h+'" alt=""></p><p>形成层叠上下文的属性条件如下：</p><p><img src="'+d+'" alt=""></p>',29),L=(0,i.Uk)("参考 "),S={href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context",target:"_blank",rel:"noopener noreferrer"},C=(0,i.Uk)("MDN 层叠上下文"),x=(0,i.Uk)("。"),P=(0,i.uE)('<h4 id="graphicslayers-图层" tabindex="-1"><a class="header-anchor" href="#graphicslayers-图层" aria-hidden="true">#</a> GraphicsLayers（图层）</h4><p>并不是所有的 PaintLayer 都能成为 GraphicsLayer，<strong>因为生成图层是会占用内存</strong>，只有某些特殊的 PaintLayer 才会被提升为 GraphicsLayer。</p><p>要能成为图层的节点除了要满足层叠上下文属性条件，还需要具有以下条件：</p><ul><li>根元素</li><li>硬件加速 <ul><li>3D transform 或 perspective 的元素</li><li>硬件加速的 video</li><li>3D 或硬件加速的 2D 的canvas</li></ul></li><li>CSS3 动画：对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是激活 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</li><li>will-change</li><li>裁剪滚动区域</li><li><strong>overlaps a composited layer 的元素</strong></li></ul><p>以上只列举常见情况，更多详情查看</p>',5),E={href:"https://fed.taobao.org/blog/taofed/do71ct/performance-composite/?spm=taofed.homepage.header.13.7eab5ac8Ut2aYd",target:"_blank",rel:"noopener noreferrer"},D=(0,i.Uk)("无线性能优化：Composite"),M={href:"https://chromium.googlesource.com/chromium/blink/+/72fef91ac1ef679207f51def8133b336a6f6588f/Source/platform/graphics/CompositingReasons.cpp?autodive=0%2F%2F%2F",target:"_blank",rel:"noopener noreferrer"},w=(0,i.Uk)("CompositingReasons.cpp"),U=(0,i.uE)('<h3 id="paint-绘制" tabindex="-1"><a class="header-anchor" href="#paint-绘制" aria-hidden="true">#</a> Paint：绘制</h3><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，但 Paint 阶段并不是真正的界面绘制，而是生成<strong>绘制指令</strong>列表，交给其他线程进行光栅任务，大大减低了主线程的负担，提高主线程效率。</p><p>可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p><p><img src="'+u+'" alt=""></p><p>生成指令的过程，每一个图层都是分为多阶段并按照层叠顺序对 layout subTree 进行遍历生成指令。</p><p>下面案列 float 布局中，一个元素甚至有可能部分地位于另一个元素的前面和一部分之后，因为先绘制所有背景完后再绘制文本。</p><p><img src="'+g+'" alt=""></p><h3 id="raster-栅格化" tabindex="-1"><a class="header-anchor" href="#raster-栅格化" aria-hidden="true">#</a> Raster（栅格化）</h3><p>光栅化，就是将绘制指令生成位图。</p><h4 id="bitmap-位图" tabindex="-1"><a class="header-anchor" href="#bitmap-位图" aria-hidden="true">#</a> bitmap（位图）</h4><h4 id="tile" tabindex="-1"><a class="header-anchor" href="#tile" aria-hidden="true">#</a> tile</h4><p>Chromium 目前实际支持三种不同的光栅化和合成的组合方式：软件光栅化 + 软件合成，软件光栅化 + gpu 合成，gpu 光栅化 + gpu 合成。在移动平台上，大部分设备和移动版网页使用的都是 gpu 光栅化 + gpu 合成的渲染方式，理论上性能也最佳。</p><p>https://www.youtube.com/watch?v=K2QHdgAKP-s</p><ol><li>dom</li><li>style</li><li>layout</li><li>layers</li><li>paint</li><li>tiling</li><li>raster</li><li>composite</li></ol><p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</p><h3 id="显示器显示图像原理" tabindex="-1"><a class="header-anchor" href="#显示器显示图像原理" aria-hidden="true">#</a> 显示器显示图像原理</h3><p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒 60 次读取显卡的<strong>前缓冲区</strong>。</p><p>显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。</p><p>渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p><blockquote><p>在 GPU 加速的场景下渲染引擎则是借助 GPU 去合成图片</p></blockquote><p>渲染引擎生成的每一张图片称为一帧，每秒更新了多少帧称为帧率，比如 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。为了保证图像显示流程，那么帧率就需要尽量达到显示器刷新频率，比如大多数设备屏幕的更新频率是 60 次 / 秒，那么渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</p><blockquote><p>现在大多数显示器刷新率在 60Hz，</p></blockquote><blockquote><p>不涉及图层的内容的操作能直接在合成线程中完成，比如操作的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容，而文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。</p></blockquote><ul><li>DOM</li><li>Style</li><li>Layout</li><li>Panit</li><li>compositing</li><li>Raster</li><li>gpu</li></ul>',24),O={},T=(0,l(3860).Z)(O,[["render",function(e,a){const l=(0,i.up)("ExternalLinkIcon");return(0,i.wg)(),(0,i.iD)("div",null,[m,f,(0,i._)("p",null,[b,(0,i._)("a",y,[k,(0,i.Wm)(l)]),_]),v,(0,i._)("p",null,[L,(0,i._)("a",S,[C,(0,i.Wm)(l)]),x]),P,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i._)("a",E,[D,(0,i.Wm)(l)])]),(0,i._)("li",null,[(0,i._)("a",M,[w,(0,i.Wm)(l)])])]),U])}]])},3860:(e,a)=>{a.Z=(e,a)=>{const l=e.__vccOpts||e;for(const[e,i]of a)l[e]=i;return l}}}]);